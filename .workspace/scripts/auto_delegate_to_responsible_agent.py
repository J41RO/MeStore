#!/usr/bin/env python3
"""
ü§ñ SISTEMA DE DELEGACI√ìN AUTOM√ÅTICA MEJORADO
Activa autom√°ticamente al agente responsable y transfiere instrucciones completas
"""

import os
import sys
import json
import time
from datetime import datetime, timedelta
from pathlib import Path

# Archivos protegidos con agentes responsables
PROTECTED_FILES = {
    "app/main.py": "system-architect-ai",
    "frontend/vite.config.ts": "frontend-performance-ai",
    "docker-compose.yml": "cloud-infrastructure-ai",
    "app/api/v1/deps/auth.py": "security-backend-ai",
    "app/services/auth_service.py": "security-backend-ai",
    "app/models/user.py": "database-architect-ai",
    "tests/conftest.py": "tdd-specialist",
    "app/core/config.py": "configuration-management",
    "app/database.py": "database-architect-ai",
    "app/core/security.py": "security-backend-ai",
    "app/models/order.py": "database-architect-ai",
    "frontend/src/contexts/AuthContext.tsx": "security-frontend-ai",
    "frontend/src/services/authService.ts": "security-frontend-ai"
}

# Agentes backup para escalaci√≥n
BACKUP_AGENTS = {
    "system-architect-ai": "solution-architect-ai",
    "frontend-performance-ai": "react-specialist-ai",
    "cloud-infrastructure-ai": "devops-integration-ai",
    "security-backend-ai": "api-security",
    "database-architect-ai": "backend-framework-ai",
    "tdd-specialist": "unit-testing-ai",
    "configuration-management": "system-architect-ai",
    "security-frontend-ai": "frontend-security-ai"
}

class AutoDelegationSystem:
    def __init__(self):
        self.requests_dir = ".workspace/requests"
        self.logs_dir = ".workspace/logs"
        self.ensure_directories()

    def ensure_directories(self):
        """Crear directorios necesarios"""
        os.makedirs(self.requests_dir, exist_ok=True)
        os.makedirs(self.logs_dir, exist_ok=True)

    def detect_protected_file_access(self, current_agent, target_file, user_instruction):
        """
        Detectar cuando un agente intenta modificar archivo protegido
        y activar autom√°ticamente delegaci√≥n
        """
        print(f"üîç Detectando acceso protegido: {current_agent} ‚Üí {target_file}")

        # Verificar si archivo est√° protegido
        if target_file not in PROTECTED_FILES:
            return {"status": "allowed", "message": "Archivo no protegido, proceder"}

        responsible_agent = PROTECTED_FILES[target_file]

        # Si es el agente responsable o master-orchestrator, permitir
        if current_agent == responsible_agent or current_agent == "master-orchestrator":
            return {"status": "allowed", "message": f"Agente autorizado: {current_agent}"}

        # Activar delegaci√≥n autom√°tica
        return self.auto_delegate_to_responsible_agent(
            current_agent, responsible_agent, target_file, user_instruction
        )

    def auto_delegate_to_responsible_agent(self, requesting_agent, responsible_agent, target_file, user_instruction):
        """
        Activar autom√°ticamente al agente responsable con instrucciones completas
        """
        print(f"üöÄ ACTIVANDO DELEGACI√ìN AUTOM√ÅTICA")
        print(f"üì§ De: {requesting_agent}")
        print(f"üì• Para: {responsible_agent}")
        print(f"üìÅ Archivo: {target_file}")

        # Crear request √∫nico
        request_id = self.generate_request_id()

        # Crear solicitud completa con toda la informaci√≥n
        delegation_request = {
            "request_id": request_id,
            "timestamp": datetime.now().isoformat(),
            "requesting_agent": requesting_agent,
            "responsible_agent": responsible_agent,
            "backup_agent": BACKUP_AGENTS.get(responsible_agent, "master-orchestrator"),
            "target_file": target_file,
            "user_instruction": user_instruction,
            "status": "DELEGATED",
            "priority": self.calculate_priority(target_file),
            "escalation_timeout": (datetime.now() + timedelta(minutes=15)).isoformat(),
            "delegation_chain": [requesting_agent, responsible_agent],
            "auto_activation": True
        }

        # Guardar solicitud
        request_file = f"{self.requests_dir}/delegation_{request_id}.json"
        with open(request_file, 'w') as f:
            json.dump(delegation_request, f, indent=2)

        # Log de delegaci√≥n
        self.log_delegation_activity(delegation_request)

        # Activar autom√°ticamente al agente responsable
        activation_result = self.activate_responsible_agent(delegation_request)

        return {
            "status": "DELEGATED",
            "request_id": request_id,
            "responsible_agent": responsible_agent,
            "message": f"Delegaci√≥n autom√°tica iniciada. Agente {responsible_agent} activado.",
            "activation_result": activation_result,
            "estimated_response_time": "5-15 minutos",
            "backup_escalation": f"Escalar√° a {BACKUP_AGENTS.get(responsible_agent, 'master-orchestrator')} si no responde"
        }

    def activate_responsible_agent(self, delegation_request):
        """
        Activar autom√°ticamente al agente responsable usando el Task tool
        """
        responsible_agent = delegation_request["responsible_agent"]
        target_file = delegation_request["target_file"]
        user_instruction = delegation_request["user_instruction"]
        request_id = delegation_request["request_id"]

        print(f"‚ö° ACTIVANDO AGENTE: {responsible_agent}")

        # Crear instrucci√≥n completa para el agente responsable
        enhanced_instruction = self.create_enhanced_instruction(
            delegation_request["requesting_agent"],
            responsible_agent,
            target_file,
            user_instruction,
            request_id
        )

        # Crear archivo de activaci√≥n para el agente responsable
        activation_file = f"{self.requests_dir}/activation_{responsible_agent}_{request_id}.md"

        activation_content = f"""# üö® ACTIVACI√ìN AUTOM√ÅTICA DE AGENTE RESPONSABLE

## üìã INFORMACI√ìN DE DELEGACI√ìN
- **Request ID**: {request_id}
- **Timestamp**: {delegation_request["timestamp"]}
- **Agente solicitante**: {delegation_request["requesting_agent"]}
- **Agente responsable**: {responsible_agent}
- **Archivo objetivo**: {target_file}
- **Prioridad**: {delegation_request["priority"]}

## üéØ INSTRUCCIONES ORIGINALES DEL USUARIO
{user_instruction}

## ü§ñ INSTRUCCIONES MEJORADAS PARA EL AGENTE
{enhanced_instruction}

## üîç EVALUACI√ìN REQUERIDA
Como {responsible_agent}, debes evaluar:

1. **Seguridad**: ¬øEs seguro modificar {target_file}?
2. **Impacto**: ¬øQu√© sistemas se ver√°n afectados?
3. **Alternativas**: ¬øHay formas m√°s seguras de lograr el objetivo?
4. **Riesgo**: ¬øCu√°l es el nivel de riesgo t√©cnico?

## üö¶ DECISIONES POSIBLES

### ‚úÖ APROBAR Y EJECUTAR
- Proceder con la modificaci√≥n
- Documentar cambios realizados
- Ejecutar tests de validaci√≥n
- Confirmar √©xito de la operaci√≥n

### ‚ö†Ô∏è APROBAR CON CONDICIONES
- Sugerir modificaciones al enfoque
- Implementar salvaguardas adicionales
- Requerir tests espec√≠ficos
- Proponer alternativas m√°s seguras

### ‚ùå RECHAZAR
- Proporcionar razones t√©cnicas detalladas
- Sugerir alternativas menos riesgosas
- Documentar por qu√© es peligroso
- Proponer soluci√≥n alternativa

## üìä INFORMACI√ìN ADICIONAL
- **Backup Agent**: {delegation_request["backup_agent"]}
- **Escalaci√≥n autom√°tica**: 15 minutos
- **Status inicial**: DELEGATED
- **Auto-activation**: TRUE

---
**‚è∞ TIEMPO L√çMITE**: 15 minutos para evaluaci√≥n
**üîÑ ESCALACI√ìN**: Autom√°tica a {delegation_request["backup_agent"]} si no respondes
**üìù LOG**: Toda la actividad se registra autom√°ticamente
"""

        # Guardar archivo de activaci√≥n
        with open(activation_file, 'w') as f:
            f.write(activation_content)

        print(f"üìÅ Archivo de activaci√≥n creado: {activation_file}")

        # Marcar como activado
        delegation_request["activation_file"] = activation_file
        delegation_request["activation_time"] = datetime.now().isoformat()
        delegation_request["status"] = "AGENT_ACTIVATED"

        # Actualizar solicitud
        request_file = f"{self.requests_dir}/delegation_{request_id}.json"
        with open(request_file, 'w') as f:
            json.dump(delegation_request, f, indent=2)

        return {
            "status": "ACTIVATED",
            "agent": responsible_agent,
            "activation_file": activation_file,
            "enhanced_instruction": enhanced_instruction,
            "timeout": "15 minutos",
            "message": f"Agente {responsible_agent} activado con instrucciones completas"
        }

    def create_enhanced_instruction(self, requesting_agent, responsible_agent, target_file, original_instruction, request_id):
        """
        Crear instrucci√≥n mejorada con contexto completo para el agente responsable
        """
        context_info = self.get_file_context(target_file)

        enhanced = f"""
ü§ñ DELEGACI√ìN AUTOM√ÅTICA DE {requesting_agent}

OBJETIVO ORIGINAL: {original_instruction}

CONTEXTO DEL ARCHIVO:
- Archivo: {target_file}
- Responsable: {responsible_agent}
- Nivel de protecci√≥n: CR√çTICO
{context_info}

INSTRUCCIONES ESPEC√çFICAS:
1. EVALUAR la seguridad de la modificaci√≥n solicitada
2. VERIFICAR que no rompa funcionalidad existente
3. CONSIDERAR alternativas m√°s seguras si las hay
4. IMPLEMENTAR la soluci√≥n si es segura
5. DOCUMENTAR todos los cambios realizados
6. EJECUTAR tests para validar que todo funciona
7. REPORTAR el resultado (√©xito/fallo/alternativa)

CRITERIOS DE EVALUACI√ìN:
- ¬øRompe la funcionalidad existente?
- ¬øIntroduce vulnerabilidades de seguridad?
- ¬øAfecta otros sistemas o servicios?
- ¬øHay una forma m√°s segura de lograr el objetivo?

ACCIONES REQUERIDAS:
- Si APRUEBAS: Ejecuta la modificaci√≥n y documenta
- Si RECHAZAS: Explica razones t√©cnicas y prop√≥n alternativas
- Si NECESITAS ACLARACI√ìN: Solicita m√°s informaci√≥n espec√≠fica

Request ID: {request_id}
Tiempo l√≠mite: 15 minutos
"""
        return enhanced

    def get_file_context(self, target_file):
        """Obtener contexto espec√≠fico del archivo"""
        contexts = {
            "app/main.py": "- Puerto 8000 FastAPI server\n- NO cambiar configuraci√≥n de puertos\n- Cr√≠tico para toda la aplicaci√≥n",
            "app/api/v1/deps/auth.py": "- Sistema JWT authentication\n- NO romper login existente\n- Afecta todos los endpoints protegidos",
            "app/models/user.py": "- Modelo cr√≠tico usuarios\n- NO crear usuarios duplicados en tests\n- Cambios afectan toda autenticaci√≥n",
            "docker-compose.yml": "- Orquestaci√≥n completa servicios\n- Puertos: backend:8000, frontend:5173\n- NO cambiar configuraci√≥n de red",
            "tests/conftest.py": "- Fixtures centrales de testing\n- NO modificar fixtures existentes\n- Usado por todo el sistema de tests"
        }
        return contexts.get(target_file, "- Archivo protegido nivel cr√≠tico\n- Requiere evaluaci√≥n cuidadosa")

    def calculate_priority(self, target_file):
        """Calcular prioridad basada en criticidad del archivo"""
        critical_files = ["app/main.py", "docker-compose.yml", "app/api/v1/deps/auth.py"]
        if target_file in critical_files:
            return "CR√çTICA"
        return "ALTA"

    def generate_request_id(self):
        """Generar ID √∫nico para la solicitud"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        return f"REQ_{timestamp}_{hash(time.time()) % 10000:04d}"

    def log_delegation_activity(self, delegation_request):
        """Registrar actividad de delegaci√≥n"""
        today = datetime.now().strftime("%Y-%m-%d")
        log_file = f"{self.logs_dir}/auto_delegation_{today}.json"

        # Leer log existente
        if os.path.exists(log_file):
            with open(log_file, 'r') as f:
                logs = json.load(f)
        else:
            logs = []

        # Agregar nueva entrada
        log_entry = {
            "timestamp": delegation_request["timestamp"],
            "request_id": delegation_request["request_id"],
            "event": "AUTO_DELEGATION_INITIATED",
            "requesting_agent": delegation_request["requesting_agent"],
            "responsible_agent": delegation_request["responsible_agent"],
            "target_file": delegation_request["target_file"],
            "status": delegation_request["status"]
        }

        logs.append(log_entry)

        # Guardar log actualizado
        with open(log_file, 'w') as f:
            json.dump(logs, f, indent=2)

        print(f"üìù Delegaci√≥n registrada en: {log_file}")

    def check_delegation_status(self, request_id):
        """Verificar estado de una delegaci√≥n"""
        request_file = f"{self.requests_dir}/delegation_{request_id}.json"

        if not os.path.exists(request_file):
            return {"error": f"Request {request_id} no encontrado"}

        with open(request_file, 'r') as f:
            delegation = json.load(f)

        # Verificar si necesita escalaci√≥n
        escalation_time = datetime.fromisoformat(delegation["escalation_timeout"])
        if datetime.now() > escalation_time and delegation["status"] == "AGENT_ACTIVATED":
            return self.escalate_to_backup(delegation)

        return delegation

    def escalate_to_backup(self, delegation_request):
        """Escalar autom√°ticamente al agente backup"""
        backup_agent = delegation_request["backup_agent"]

        print(f"üö® ESCALANDO A BACKUP AGENT: {backup_agent}")

        delegation_request["status"] = "ESCALATED_TO_BACKUP"
        delegation_request["escalation_time"] = datetime.now().isoformat()
        delegation_request["escalation_reason"] = "Timeout - no response from primary agent"
        delegation_request["delegation_chain"].append(backup_agent)

        # Crear nueva activaci√≥n para backup
        backup_activation = self.activate_responsible_agent({
            **delegation_request,
            "responsible_agent": backup_agent
        })

        # Actualizar request
        request_file = f"{self.requests_dir}/delegation_{delegation_request['request_id']}.json"
        with open(request_file, 'w') as f:
            json.dump(delegation_request, f, indent=2)

        return {
            "status": "ESCALATED",
            "backup_agent": backup_agent,
            "escalation_reason": "Primary agent timeout",
            "new_timeout": "10 minutos adicionales"
        }


def main():
    """Funci√≥n principal para uso directo del script"""
    if len(sys.argv) < 4:
        print("‚ùå Uso: python auto_delegate_to_responsible_agent.py <current_agent> <target_file> '<user_instruction>'")
        print("üîß Ejemplo: python auto_delegate_to_responsible_agent.py backend-framework-ai app/main.py 'Agregar endpoint de salud'")
        sys.exit(1)

    current_agent = sys.argv[1]
    target_file = sys.argv[2]
    user_instruction = sys.argv[3]

    # Inicializar sistema de delegaci√≥n
    delegation_system = AutoDelegationSystem()

    print(f"ü§ñ SISTEMA DE DELEGACI√ìN AUTOM√ÅTICA ACTIVADO")
    print(f"üì§ Agente actual: {current_agent}")
    print(f"üìÅ Archivo objetivo: {target_file}")
    print(f"üìã Instrucci√≥n: {user_instruction}")
    print("-" * 70)

    # Detectar y procesar acceso a archivo protegido
    result = delegation_system.detect_protected_file_access(
        current_agent, target_file, user_instruction
    )

    if result["status"] == "allowed":
        print(f"‚úÖ {result['message']}")
        print("üöÄ PUEDE PROCEDER con la modificaci√≥n")

    elif result["status"] == "DELEGATED":
        print(f"üîÑ DELEGACI√ìN AUTOM√ÅTICA ACTIVADA")
        print(f"üìã Request ID: {result['request_id']}")
        print(f"ü§ñ Agente responsable: {result['responsible_agent']}")
        print(f"‚è∞ Tiempo estimado: {result['estimated_response_time']}")
        print(f"üîÑ Backup: {result['backup_escalation']}")
        print("")
        print("üéØ EL AGENTE RESPONSABLE HA SIDO ACTIVADO AUTOM√ÅTICAMENTE")
        print("üì® Las instrucciones completas han sido transferidas")
        print("‚åõ Esperando evaluaci√≥n y decisi√≥n del agente especializado...")

        # Mostrar informaci√≥n de seguimiento
        print(f"\nüìä SEGUIMIENTO:")
        print(f"üîç Check status: python .workspace/scripts/check_delegation_status.py {result['request_id']}")
        print(f"üìÇ Activaci√≥n: {result['activation_result']['activation_file']}")

if __name__ == "__main__":
    main()