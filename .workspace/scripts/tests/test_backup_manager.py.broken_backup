"""
Tests para BackupManager de Surgical Modifier Ultimate v5.3
"""

import pytest
import os
import tempfile
from unittest.mock import patch, MagicMock
import sys

# Importar el módulo principal
try:
    from surgical_modifier_ultimate import BackupManager
except ImportError:
    # Fallback si hay problemas de importación
    sys.path.append('..')
    from surgical_modifier_ultimate import BackupManager

class TestBackupManager:
    """Tests para la clase BackupManager"""

    @pytest.fixture
    def backup_manager(self, temp_dir):
        """Crear instancia de BackupManager para testing"""
        return BackupManager(
            keep_successful_backups=False,
            max_backups=5

        )

    def test_backup_manager_initialization(self, backup_manager, temp_dir):
        """Test: Inicialización correcta del BackupManager"""
        assert backup_manager.project_root == temp_dir
        assert backup_manager.keep_backups is False
        assert backup_manager.verbose is True
        assert backup_manager.backup_dir is not None

    def test_create_backup_directory(self, backup_manager):
        """Test: Creación del directorio de backup"""
        backup_dir = backup_manager._ensure_backup_dir()
        assert os.path.exists(backup_dir)
        assert os.path.isdir(backup_dir)

    def test_backup_file_creation(self, backup_manager, sample_text_file):
        """Test: Creación de backup de archivo"""
        # Crear backup
        backup_path = backup_manager.create_backup(sample_text_file)

        # Verificar que el backup existe
        assert os.path.exists(backup_path)

        # Verificar que el contenido es idéntico
        with open(sample_text_file, 'r') as original:
            original_content = original.read()

        with open(backup_path, 'r') as backup:
            backup_content = backup.read()

        assert original_content == backup_content

    def test_backup_file_nonexistent(self, backup_manager):
        """Test: Manejo de archivos que no existen"""
        nonexistent_file = "/path/that/does/not/exist.txt"
        backup_path = backup_manager.create_backup(nonexistent_file)

        # Debe retornar None o manejar el error gracefully
        assert backup_path is None or not os.path.exists(backup_path)

    def test_cleanup_backups(self, backup_manager, sample_text_file):
        """Test: Limpieza de backups cuando keep_backups=False"""
        # Crear backup
        backup_path = backup_manager.create_backup(sample_text_file)
        assert os.path.exists(backup_path)

        # Limpiar backup
        backup_manager.cleanup_backup(backup_path)

        # Si keep_backups=False, el backup debe eliminarse
        if not backup_manager.keep_backups:
            assert not os.path.exists(backup_path)

    @pytest.mark.unit
    def test_backup_filename_generation(self, backup_manager):
        """Test: Generación correcta de nombres de backup"""
        test_file = "/some/path/test.py"
        backup_name = backup_manager._generate_backup_name(test_file)

        # Debe contener el nombre del archivo original
        assert "test.py" in backup_name
        # Debe tener timestamp
        assert len(backup_name) > len("test.py")
