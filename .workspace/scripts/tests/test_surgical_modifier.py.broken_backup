"""
Tests principales para SurgicalModifierUltimate v5.3
"""

import pytest
import os
import tempfile
from unittest.mock import patch, MagicMock
import sys

# Importar el módulo principal
try:
    from surgical_modifier_ultimate import SurgicalModifierUltimate
except ImportError:
    sys.path.append('..')
    from surgical_modifier_ultimate import SurgicalModifierUltimate

class TestSurgicalModifierUltimate:
    """Tests para la clase principal SurgicalModifierUltimate"""

    @pytest.fixture
    def modifier(self, temp_dir):
        """Crear instancia de SurgicalModifierUltimate para testing"""
        return SurgicalModifierUltimate(

            verbose=True,
            confirm=False,
            keep_backups=False
        )

    def test_modifier_initialization(self, modifier, temp_dir):
        """Test: Inicialización correcta del modifier"""
        assert modifier.project_root == temp_dir
        assert modifier.verbose is True
        assert modifier.confirm is False
        assert modifier.keep_backups is False

    def test_file_exists_check(self, modifier, sample_python_file):
        """Test: Verificación de existencia de archivos"""
        # Archivo que existe
        assert modifier._file_exists(sample_python_file) is True

        # Archivo que no existe
        nonexistent = "/path/that/does/not/exist.py"
        assert modifier._file_exists(nonexistent) is False

    def test_read_file_content(self, modifier, sample_python_file):
        """Test: Lectura correcta de contenido de archivos"""
        content = modifier._read_file_content(sample_python_file)

        assert content is not None
        assert isinstance(content, str)
        assert "SampleClass" in content
        assert "def sample_method" in content

    def test_write_file_content(self, modifier, temp_dir):
        """Test: Escritura correcta de contenido a archivos"""
        test_file = os.path.join(temp_dir, "test_write.py")
        test_content = "# Test content\nprint('Hello World')\n"

        success = modifier._write_file_content(test_file, test_content)

        assert success is True
        assert os.path.exists(test_file)

        # Verificar contenido
        with open(test_file, 'r') as f:
            written_content = f.read()

        assert written_content == test_content

    def test_pattern_search(self, modifier, sample_python_file):
        """Test: Búsqueda de patrones en archivos"""
        # Buscar patrón que existe
        pattern = "def sample_method"
        found = modifier._search_pattern(sample_python_file, pattern)

        assert found is True

        # Buscar patrón que no existe
        pattern_not_found = "def nonexistent_method"
        not_found = modifier._search_pattern(sample_python_file, pattern_not_found)

        assert not_found is False

    def test_simple_replace_operation(self, modifier, sample_python_file):
        """Test: Operación básica de reemplazo"""
        original_pattern = "original_value"
        new_content = "modified_value"

        # Verificar que el patrón original existe
        with open(sample_python_file, 'r') as f:
            original_content = f.read()
        assert original_pattern in original_content

        # Ejecutar reemplazo
        result = modifier.replace_content(
            file_path=sample_python_file,
            pattern=original_pattern,
            new_content=new_content
        )

        # Verificar resultado
        assert result is True

        # Verificar que el cambio se aplicó
        with open(sample_python_file, 'r') as f:
            modified_content = f.read()

        assert new_content in modified_content
        assert original_pattern not in modified_content

    def test_backup_creation_during_operation(self, modifier, sample_python_file):
        """Test: Creación de backup durante operaciones"""
        # Configurar para mantener backups temporalmente
        modifier.keep_backups = True

        original_content = modifier._read_file_content(sample_python_file)

        # Ejecutar operación
        result = modifier.replace_content(
            file_path=sample_python_file,
            pattern="original_value",
            new_content="backup_test_value"
        )

        assert result is True

        # Verificar que se creó backup (esto depende de la implementación)
        # El backup puede estar en un directorio específico
        backup_dir = os.path.join(modifier.project_root, '.backup')
        if os.path.exists(backup_dir):
            backup_files = os.listdir(backup_dir)
            assert len(backup_files) > 0

    def test_error_handling_invalid_file(self, modifier):
        """Test: Manejo de errores con archivos inválidos"""
        invalid_file = "/path/that/does/not/exist.py"

        result = modifier.replace_content(
            file_path=invalid_file,
            pattern="any_pattern",
            new_content="any_content"
        )

        # Debe manejar el error gracefully
        assert result is False or result is None

    @pytest.mark.integration
    def test_multiple_operations_same_file(self, modifier, sample_python_file):
        """Test: Múltiples operaciones en el mismo archivo"""
        operations = [
            ("original_value", "first_change"),
            ("Hello World", "Hello Universe"),
            ("test", "production")
        ]

        for pattern, replacement in operations:
            # Verificar si el patrón existe antes de intentar reemplazar
            content = modifier._read_file_content(sample_python_file)
            if pattern in content:
                result = modifier.replace_content(
                    file_path=sample_python_file,
                    pattern=pattern,
                    new_content=replacement
                )
                assert result is True

    @pytest.mark.unit
    def test_pattern_validation(self, modifier):
        """Test: Validación de patrones"""
        # Patrones válidos
        valid_patterns = [
            "def method_name",
            "class ClassName",
            "import module",
            "# Comment"
        ]

        for pattern in valid_patterns:
            # El patrón debe ser procesable (no debe fallar)
            assert isinstance(pattern, str)
            assert len(pattern) > 0

        # Patrones problemáticos
        problematic_patterns = ["", None]

        for pattern in problematic_patterns:
            # Debe manejar patrones problemáticos
            if pattern is None or pattern == "":
                # El modifier debe validar estos casos
                assert True  # Placeholder para validación específica
