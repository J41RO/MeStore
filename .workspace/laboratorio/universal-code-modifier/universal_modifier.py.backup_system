#!/usr/bin/env python3
"""
Universal Code Modifier
import time
Una herramienta para modificar c√≥digo de forma universal y segura.
Permite aplicar transformaciones y modificaciones a diferentes tipos de archivos de c√≥digo.

Author: Laboratorio de Desarrollo
Version: 0.1.0

    
    Sistema de Logging Avanzado:
    ---------------------------
    - LoggerManager centralizado para configuraci√≥n profesional
    - Soporte para handlers m√∫ltiples: consola, archivo, rotating
    - Logging contextual con informaci√≥n de operaciones
    - Performance timing autom√°tico
    - Configuraci√≥n din√°mica de niveles y formatos
    """

import os
import time
import sys
import logging
from pathlib import Path
from typing import List, Dict, Optional, Union
from abc import ABC, abstractmethod


# ============================================================================
# CONSTANTES Y CONFIGURACIONES GLOBALES
# ============================================================================

# Informaci√≥n del proyecto
PROJECT_NAME = "Universal Code Modifier"
VERSION = "0.1.3"
AUTHOR = "Laboratorio de Desarrollo"

# ============================================================================
# CONFIGURACIONES DE ARCHIVOS Y EXTENSIONES
# ============================================================================

# Extensiones de archivos soportadas por defecto
DEFAULT_SUPPORTED_EXTENSIONS = [
    '.py',      # Python
    '.js',      # JavaScript
    '.ts',      # TypeScript
    '.java',    # Java
    '.cpp',     # C++
    '.c',       # C
    '.cs',      # C#
    '.go',      # Go
    '.rs',      # Rust
    '.php',     # PHP
    '.rb',      # Ruby
    '.swift',   # Swift
    '.kt',      # Kotlin
]

# Mapeo de extensiones a lenguajes
EXTENSION_TO_LANGUAGE = {
    '.py': 'Python',
    '.js': 'JavaScript', 
    '.ts': 'TypeScript',
    '.java': 'Java',
    '.cpp': 'C++',
    '.c': 'C',
    '.cs': 'C#',
    '.go': 'Go',
    '.rs': 'Rust',
    '.php': 'PHP',
    '.rb': 'Ruby',
    '.swift': 'Swift',
    '.kt': 'Kotlin',
}

# ============================================================================
# CONFIGURACIONES DE DIRECTORIO Y EXCLUSIONES
# ============================================================================

# Directorios excluidos por defecto
DEFAULT_EXCLUDED_DIRS = {
    '.git',          # Control de versiones Git
    '__pycache__',   # Cache de Python
    'node_modules',  # Dependencias de Node.js
    '.venv',         # Entorno virtual Python
    'venv',          # Entorno virtual Python alternativo
    '.idea',         # Archivos de IntelliJ IDEA
    '.vscode',       # Archivos de Visual Studio Code
    'build',         # Directorio de build
    'dist',          # Directorio de distribuci√≥n
    'target',        # Directorio target (Java/Maven)
    '.next',         # Archivos de Next.js
    '.nuxt',         # Archivos de Nuxt.js
}

# ============================================================================
# CONFIGURACIONES DE ENCODING Y ARCHIVOS
# ============================================================================

# Encodings a probar para leer archivos
SUPPORTED_ENCODINGS = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1']

# Encoding por defecto para nuevos archivos
DEFAULT_FILE_ENCODING = 'utf-8'

# ============================================================================
# CONFIGURACIONES DE TAMA√ëO Y L√çMITES
# ============================================================================

# Factores de conversi√≥n
BYTES_PER_KB = 1024
BYTES_PER_MB = 1024 * 1024
BYTES_PER_GB = 1024 * 1024 * 1024

# Tama√±os por defecto
DEFAULT_MAX_FILE_SIZE_MB = 10
DEFAULT_MAX_FILE_SIZE_BYTES = DEFAULT_MAX_FILE_SIZE_MB * BYTES_PER_MB

# L√≠mites de seguridad
MAX_ALLOWED_FILE_SIZE_MB = 100
MIN_ALLOWED_FILE_SIZE_MB = 1

# ============================================================================
# CONFIGURACIONES DE LOGGING
# ============================================================================

# Niveles de logging v√°lidos
VALID_LOG_LEVELS = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}

# Nivel de logging por defecto
DEFAULT_LOG_LEVEL = 'INFO'

# Formato de logging por defecto
DEFAULT_LOG_FORMAT = '%(asctime)s - %(name)s - %(levelname)s - %(message)s'


class LoggerManager:
    """Gestor centralizado para configuraci√≥n de logging del Universal Code Modifier"""
    
    def __init__(self, name: str = None, level: str = DEFAULT_LOG_LEVEL, format_str: str = DEFAULT_LOG_FORMAT):
        self.name = name or __name__
        self.level = getattr(logging, level.upper())
        self.format_str = format_str
        self.logger = logging.getLogger(self.name)
        self.logger.setLevel(self.level)
        self.formatters = {}
        self.handlers = {}
    
    def create_formatter(self, format_str: str = None) -> logging.Formatter:
        """Crea formatter con formato especificado o por defecto"""
        fmt = format_str or self.format_str
        if fmt not in self.formatters:
            self.formatters[fmt] = logging.Formatter(fmt)
        return self.formatters[fmt]
    
    def setup_console_handler(self, level: str = None, format_str: str = None) -> logging.StreamHandler:
        """Configura handler de consola"""
        handler_key = 'console'
        if handler_key not in self.handlers:
            handler = logging.StreamHandler()
            handler.setLevel(getattr(logging, (level or DEFAULT_LOG_LEVEL).upper()))
            handler.setFormatter(self.create_formatter(format_str))
            self.logger.addHandler(handler)
            self.handlers[handler_key] = handler
        return self.handlers[handler_key]
    
    def setup_file_handler(self, filename: str, level: str = None, format_str: str = None) -> logging.FileHandler:
        """Configura handler de archivo"""
        handler_key = f'file_{filename}'
        if handler_key not in self.handlers:
            handler = logging.FileHandler(filename)
            handler.setLevel(getattr(logging, (level or DEFAULT_LOG_LEVEL).upper()))
            handler.setFormatter(self.create_formatter(format_str))
            self.logger.addHandler(handler)
            self.handlers[handler_key] = handler
        return self.handlers[handler_key]
    
    def log_operation_start(self, operation: str, context: dict = None):
        """Log inicio de operaci√≥n con contexto"""
        ctx_str = f" | Contexto: {context}" if context else ""
        self.logger.info(f"üîÑ INICIANDO: {operation}{ctx_str}")
    
    def log_operation_end(self, operation: str, success: bool = True, context: dict = None):
        """Log fin de operaci√≥n con resultado"""
        status = "‚úÖ COMPLETADO" if success else "‚ùå FALL√ì"
        ctx_str = f" | Contexto: {context}" if context else ""
        self.logger.info(f"{status}: {operation}{ctx_str}")
    
    def log_performance(self, operation: str, duration: float, context: dict = None):
        """Log informaci√≥n de performance"""
        ctx_str = f" | Contexto: {context}" if context else ""
        self.logger.info(f"‚è±Ô∏è PERFORMANCE: {operation} ejecutado en {duration:.3f}s{ctx_str}")
    
    def log_error_with_context(self, operation: str, error: Exception, context: dict = None):
        """Log error con contexto completo"""
        ctx_str = f" | Contexto: {context}" if context else ""
        self.logger.error(f"üö® ERROR en {operation}: {str(error)}{ctx_str}", exc_info=True)


# ============================================================================
# CONFIGURACIONES DE BACKUP Y SEGURIDAD
# ============================================================================

# Sufijo para archivos de backup
BACKUP_SUFFIX = '.backup'

# Configuraciones por defecto de seguridad
DEFAULT_BACKUP_ENABLED = True
DEFAULT_DRY_RUN_MODE = False
DEFAULT_VALIDATE_SYNTAX = True

# ============================================================================
# CONFIGURACIONES DE COMENTARIOS POR LENGUAJE
# ============================================================================

# Prefijos de comentarios de l√≠nea por lenguaje
SINGLE_LINE_COMMENT_PREFIXES = {
    'Python': '#',
    'JavaScript': '//',
    'TypeScript': '//',
    'Java': '//',
    'C++': '//',
    'C': '//',
    'C#': '//',
    'Go': '//',
    'Rust': '//',
    'PHP': '//',
    'Swift': '//',
    'Kotlin': '//',
}

# Delimitadores de comentarios multil√≠nea
MULTI_LINE_COMMENT_DELIMITERS = {
    'Python': ('"""', '"""'),
    'JavaScript': ('/*', '*/'),
    'TypeScript': ('/*', '*/'),
    'Java': ('/*', '*/'),
    'C++': ('/*', '*/'),
    'C': ('/*', '*/'),
    'C#': ('/*', '*/'),
    'Go': ('/*', '*/'),
    'Rust': ('/*', '*/'),
    'PHP': ('/*', '*/'),
    'Swift': ('/*', '*/'),
    'Kotlin': ('/*', '*/'),
}

# ============================================================================
# CONFIGURACIONES POR DEFECTO PARA LA CLASE
# ============================================================================

# Configuraci√≥n por defecto completa
DEFAULT_CONFIG = {
    'backup_enabled': DEFAULT_BACKUP_ENABLED,
    'dry_run_mode': DEFAULT_DRY_RUN_MODE,
    'max_file_size_mb': DEFAULT_MAX_FILE_SIZE_MB,
    'file_encoding': DEFAULT_FILE_ENCODING,
    'validate_syntax': DEFAULT_VALIDATE_SYNTAX,
    'log_level': DEFAULT_LOG_LEVEL,
    'supported_extensions': DEFAULT_SUPPORTED_EXTENSIONS.copy(),
    'excluded_dirs': DEFAULT_EXCLUDED_DIRS.copy(),
}

# ============================================================================
# FIN DE CONSTANTES Y CONFIGURACIONES GLOBALES
# ============================================================================

# Configurar logging
# Configuraci√≥n centralizada de logging via LoggerManager
# global_logger_manager = LoggerManager()  # Movido a clase
# global_logger_manager.setup_console_handler()  # Movido a clase


class UniversalCodeModifier:
    """
    Clase principal para modificaciones universales de c√≥digo.
    
    Esta clase proporciona la funcionalidad base para modificar
    archivos de c√≥digo de diferentes lenguajes de forma segura y controlada.
    """
    def __init__(self, 
                 base_path: Optional[str] = None,
                 backup_enabled: bool = True,
                 dry_run_mode: bool = False,
                 max_file_size_mb: int = 10,
                 custom_extensions: Optional[List[str]] = None,
                 excluded_dirs: Optional[List[str]] = None,
                 log_level: str = DEFAULT_LOG_LEVEL,
                 backup_dir: Optional[str] = None,
                 file_encoding: str = DEFAULT_FILE_ENCODING,
                 validate_syntax: bool = True):
        """
        Inicializar el modificador universal de c√≥digo con configuraci√≥n avanzada.
        
        Args:
            base_path (str, optional): Ruta base para operaciones de archivos
            backup_enabled (bool): Si crear respaldos autom√°ticamente (default: True)
            dry_run_mode (bool): Modo de prueba sin modificaciones reales (default: False)
            max_file_size_mb (int): Tama√±o m√°ximo de archivo en MB (default: 10)
            custom_extensions (List[str], optional): Extensiones personalizadas adicionales
            excluded_dirs (List[str], optional): Directorios a excluir del procesamiento
            log_level (str): Nivel de logging (DEBUG, INFO, WARNING, ERROR) (default: INFO)
            backup_dir (str, optional): Directorio espec√≠fico para backups
            file_encoding (str): Encoding por defecto para archivos (default: utf-8)
            validate_syntax (bool): Si validar sintaxis antes de modificar (default: True)
            
        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            FileNotFoundError: Si base_path no existe
            PermissionError: Si no hay permisos en el directorio base
        """
        # Validaci√≥n y configuraci√≥n de base_path
        if base_path:
            self.base_path = Path(base_path).resolve()
            if not self.base_path.exists():
                raise FileNotFoundError(f"El directorio base no existe: {self.base_path}")
            if not self.base_path.is_dir():
                raise ValueError(f"base_path debe ser un directorio: {self.base_path}")
            if not os.access(self.base_path, os.R_OK):
                raise PermissionError(f"Sin permisos de lectura en: {self.base_path}")
        else:
            self.base_path = Path.cwd()
        
        # Configuraci√≥n de extensiones soportadas
        self.default_extensions = DEFAULT_SUPPORTED_EXTENSIONS.copy()
        if custom_extensions:
            # Validar formato de extensiones personalizadas
            validated_extensions = []
            for ext in custom_extensions:
                if not ext.startswith('.'):
                    ext = '.' + ext
                if len(ext) > 1 and ext.isascii():
                    validated_extensions.append(ext.lower())
                else:
                    self.logger.warning(f"Extensi√≥n inv√°lida ignorada: {ext}")
            self.supported_extensions = list(set(self.default_extensions + validated_extensions))
        else:
            self.supported_extensions = self.default_extensions.copy()
        
        # Configuraci√≥n de directorios excluidos
        default_excluded = DEFAULT_EXCLUDED_DIRS.copy()
        if excluded_dirs:
            self.excluded_dirs = default_excluded.union(set(excluded_dirs))
        else:
            self.excluded_dirs = default_excluded
        
        # Configuraci√≥n de tama√±o m√°ximo de archivo
        if max_file_size_mb <= 0:
            raise ValueError("max_file_size_mb debe ser mayor a 0")
        self.max_file_size = max_file_size_mb * BYTES_PER_MB  # Convertir a bytes
        
        # Configuraci√≥n de backup
        self.backup_enabled = backup_enabled
        if backup_dir:
            self.backup_dir = Path(backup_dir)
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True, exist_ok=True)
        else:
            self.backup_dir = None
        
        # Configuraci√≥n de modo de operaci√≥n
        self.dry_run_mode = dry_run_mode
        self.validate_syntax = validate_syntax
        self.file_encoding = file_encoding
        
        # Validar encoding
        try:
            "test".encode(file_encoding)
        except LookupError:
            raise ValueError(f"Encoding no v√°lido: {file_encoding}")
        
        # Configuraci√≥n de logging
        valid_log_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
        if log_level.upper() not in valid_log_levels:
            raise ValueError(f"log_level debe ser uno de: {valid_log_levels}")
        
        # Usar LoggerManager para configuraci√≥n avanzada
        self.logger_manager = LoggerManager(f"{__name__}.{self.__class__.__name__}", log_level)
        # self.logger_manager.setup_console_handler(log_level)  # Handler ya configurado globalmente
        self.logger = self.logger_manager.logger
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        
        # Configuraci√≥n adicional
        self.config = {
            'base_path': str(self.base_path),
            'backup_enabled': self.backup_enabled,
            'dry_run_mode': self.dry_run_mode,
            'max_file_size_mb': max_file_size_mb,
            'supported_extensions': self.supported_extensions,
            'excluded_dirs': list(self.excluded_dirs),
            'log_level': log_level.upper(),
            'file_encoding': self.file_encoding,
            'validate_syntax': self.validate_syntax
        }
        
        # Log de inicializaci√≥n
        self.logger.info(f"UniversalCodeModifier inicializado exitosamente")
        self.logger.info(f"Directorio base: {self.base_path}")
        self.logger.info(f"Modo dry-run: {self.dry_run_mode}")
        self.logger.info(f"Backup habilitado: {self.backup_enabled}")
        self.logger.info(f"Extensiones soportadas: {len(self.supported_extensions)} tipos")
        self.logger.debug(f"Configuraci√≥n completa: {self.config}")


    def get_config(self) -> Dict[str, any]:
        """
        Obtener la configuraci√≥n actual del modificador.
        
        Returns:
            Dict: Configuraci√≥n completa actual
        """
        current_config = self.config.copy()
        current_config.update({
            'modification_count': self.modification_count,
            'files_processed': self.files_processed,
            'errors_count': self.errors_count,
            'uptime_seconds': self._get_uptime()
        })
        return current_config
    
    def update_config(self, **kwargs) -> bool:
        """
        Actualizar configuraci√≥n en tiempo de ejecuci√≥n.
        
        Args:
            **kwargs: Par√°metros de configuraci√≥n a actualizar
            
        Returns:
            bool: True si la actualizaci√≥n fue exitosa
        """
        valid_params = {
            'backup_enabled', 'dry_run_mode', 'max_file_size_mb', 
            'log_level', 'file_encoding', 'validate_syntax'
        }
        
        updated = False
        for key, value in kwargs.items():
            if key not in valid_params:
                self.logger.warning(f"Par√°metro de configuraci√≥n inv√°lido: {key}")
                continue
                
            try:
                if key == 'max_file_size_mb':
                    if value <= 0:
                        raise ValueError("max_file_size_mb debe ser mayor a 0")
                    self.max_file_size = value * 1024 * 1024
                    self.config[key] = value
                elif key == 'log_level':
                    valid_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
                    if value.upper() not in valid_levels:
                        raise ValueError(f"log_level debe ser uno de: {valid_levels}")
                    self.logger.setLevel(getattr(logging, value.upper()))
                    self.config[key] = value.upper()
                elif key == 'file_encoding':
                    "test".encode(value)  # Validar encoding
                    setattr(self, key, value)
                    self.config[key] = value
                else:
                    setattr(self, key, value)
                    self.config[key] = value
                
                updated = True
                self.logger.info(f"Configuraci√≥n actualizada: {key} = {value}")
                
            except Exception as e:
                self.logger.error(f"Error actualizando {key}: {e}")
                return False
        
        return updated
    
    def reset_counters(self):
        """Resetear contadores de estad√≠sticas."""
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        self.logger.info("Contadores de estad√≠sticas reseteados")
    
    def validate_permissions(self) -> bool:
        """
        Validar permisos en el directorio base.
        
        Returns:
            bool: True si tiene permisos necesarios
        """
        try:
            # Verificar lectura
            if not os.access(self.base_path, os.R_OK):
                self.logger.error(f"Sin permisos de lectura en: {self.base_path}")
                return False
            
            # Verificar escritura si no es dry-run
            if not self.dry_run_mode and not os.access(self.base_path, os.W_OK):
                self.logger.error(f"Sin permisos de escritura en: {self.base_path}")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error validando permisos: {e}")
            return False
    
    def _get_uptime(self) -> float:
        """
        Calcular tiempo de vida de la instancia.
        
        Returns:
            float: Tiempo en segundos desde la inicializaci√≥n
        """
        if not self.start_time:
            self.start_time = time.time()
            return 0.0
        return time.time() - self.start_time
    
    def get_stats(self) -> Dict[str, any]:
        """
        Obtener estad√≠sticas de la sesi√≥n actual.
        
        Returns:
            Dict: Estad√≠sticas detalladas
        """
        uptime = self._get_uptime()
        return {
            'files_processed': self.files_processed,
            'modifications_made': self.modification_count,
            'errors_encountered': self.errors_count,
            'uptime_seconds': uptime,
            'uptime_formatted': f"{uptime:.2f}s",
            'success_rate': (
                (self.files_processed - self.errors_count) / max(self.files_processed, 1) * 100
                if self.files_processed > 0 else 0.0
            ),
            'avg_files_per_second': self.files_processed / max(uptime, 1) if uptime > 0 else 0.0
        }


    def get_project_info(self) -> Dict[str, str]:
        """
        Obtener informaci√≥n del proyecto y constantes globales.
        
        Returns:
            Dict: Informaci√≥n del proyecto y configuraciones
        """
        return {
            'project_name': PROJECT_NAME,
            'version': VERSION,
            'author': AUTHOR,
            'supported_extensions_count': len(DEFAULT_SUPPORTED_EXTENSIONS),
            'excluded_dirs_count': len(DEFAULT_EXCLUDED_DIRS),
            'supported_encodings_count': len(SUPPORTED_ENCODINGS),
            'default_max_file_size_mb': DEFAULT_MAX_FILE_SIZE_MB,
            'default_encoding': DEFAULT_FILE_ENCODING,
            'default_log_level': DEFAULT_LOG_LEVEL,
        }
    
    @staticmethod
    def get_all_constants() -> Dict[str, any]:
        """
        Obtener todas las constantes globales definidas.
        
        Returns:
            Dict: Todas las constantes organizadas por categor√≠a
        """
        return {
            'project_info': {
                'name': PROJECT_NAME,
                'version': VERSION,
                'author': AUTHOR,
            },
            'file_extensions': {
                'supported': DEFAULT_SUPPORTED_EXTENSIONS,
                'language_mapping': EXTENSION_TO_LANGUAGE,
            },
            'directories': {
                'excluded': list(DEFAULT_EXCLUDED_DIRS),
            },
            'file_settings': {
                'encodings': SUPPORTED_ENCODINGS,
                'default_encoding': DEFAULT_FILE_ENCODING,
                'max_size_mb': DEFAULT_MAX_FILE_SIZE_MB,
            },
            'logging': {
                'valid_levels': list(VALID_LOG_LEVELS),
                'default_level': DEFAULT_LOG_LEVEL,
                'format': DEFAULT_LOG_FORMAT,
            },
            'backup': {
                'suffix': BACKUP_SUFFIX,
                'enabled_by_default': DEFAULT_BACKUP_ENABLED,
            },
            'comments': {
                'single_line': SINGLE_LINE_COMMENT_PREFIXES,
                'multi_line': MULTI_LINE_COMMENT_DELIMITERS,
            }
        }

    def validate_file(self, file_path: Union[str, Path]) -> bool:
        """
        Validar que el archivo existe y es modificable.
        
        Args:
            file_path: Ruta al archivo a validar
            
        Returns:
            bool: True si el archivo es v√°lido, False en caso contrario
        """
        path = Path(file_path)
        
        if not path.exists():
            self.logger.error(f"Archivo no encontrado: {path}")
            return False
            
        if not path.is_file():
            self.logger.error(f"La ruta no es un archivo: {path}")
            return False
            
        if path.suffix not in self.supported_extensions:
            self.logger.warning(f"Extensi√≥n no soportada: {path.suffix}")
            return False
            
        return True
    
    def create_backup(self, file_path: Union[str, Path]) -> Optional[Path]:
        """
        Crear respaldo de un archivo antes de modificarlo.
        
        Args:
            file_path: Ruta al archivo original
            
        Returns:
            Path: Ruta al archivo de respaldo creado, None si falla
        """
        if not self.backup_enabled:
            return None
            
        original_path = Path(file_path)
        backup_path = original_path.with_suffix(f"{original_path.suffix}.backup")
        
        try:
            backup_path.write_text(original_path.read_text(encoding='utf-8'))
            self.logger.info(f"Backup creado: {backup_path}")
            return backup_path
        except Exception as e:
            self.logger.error(f"Error creando backup: {e}")
            return None
    
    def list_files(self, directory: Optional[Union[str, Path]] = None, 
                   recursive: bool = True) -> List[Path]:
        """
        Listar archivos de c√≥digo en un directorio.
        
        Args:
            directory: Directorio a escanear (por defecto: base_path)
            recursive: Si buscar recursivamente en subdirectorios
            
        Returns:
            List[Path]: Lista de archivos encontrados
        """
        search_path = Path(directory) if directory else self.base_path
        found_files = []
        
        try:
            if recursive:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.rglob(f"*{ext}"))
            else:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.glob(f"*{ext}"))
                    
            self.logger.info(f"Encontrados {len(found_files)} archivos en {search_path}")
            return sorted(found_files)
            
        except Exception as e:
            self.logger.error(f"Error listando archivos: {e}")
            return []


    def detect_language(self, file_path: Union[str, Path]) -> Optional[str]:
        """
        Detectar el lenguaje de programaci√≥n basado en la extensi√≥n del archivo.
        """
        path = Path(file_path)
        # Usar mapeo global de extensiones a lenguajes
        language = EXTENSION_TO_LANGUAGE.get(path.suffix.lower())
        return EXTENSION_TO_LANGUAGE.get(path.suffix.lower(), "Unknown")

    def analyze_file_metrics(self, file_path: Union[str, Path]) -> Dict[str, int]:
        """
        Analizar m√©tricas b√°sicas de un archivo de c√≥digo.
        """
        content = self.read_file_safe(file_path) if hasattr(self, 'read_file_safe') else None
        if not content:
            try:
                content = Path(file_path).read_text()
            except:
                return {}
        lines = content.split('\n')
        return {
            'total_lines': len(lines),
            'non_empty_lines': len([line for line in lines if line.strip()]),
            'total_characters': len(content)
        }



def main():
    """Funci√≥n principal para demostraci√≥n de constantes y configuraciones globales."""
    print(f"{PROJECT_NAME} v{VERSION}")
    print(f"Desarrollado por: {AUTHOR}")
    print("=" * 70)
    
    # Demostrar informaci√≥n del proyecto
    print("\nüìã Informaci√≥n del Proyecto:")
    modifier = UniversalCodeModifier()
    project_info = modifier.get_project_info()
    for key, value in project_info.items():
        print(f"  {key.replace('_', ' ').title()}: {value}")
    
    # Demostrar configuraci√≥n con constantes
    print("\nüîß Configuraci√≥n con Constantes Globales:")
    constants = UniversalCodeModifier.get_all_constants()
    
    # Mostrar extensiones soportadas
    print(f"  Extensiones soportadas: {len(constants['file_extensions']['supported'])}")
    print(f"  Primeras 5: {constants['file_extensions']['supported'][:5]}")
    
    # Mostrar configuraciones de archivo
    print(f"  Encodings soportados: {len(constants['file_settings']['encodings'])}")
    print(f"  Encoding por defecto: {constants['file_settings']['default_encoding']}")
    print(f"  Tama√±o m√°ximo por defecto: {constants['file_settings']['max_size_mb']}MB")
    
    # Mostrar directorios excluidos
    print(f"  Directorios excluidos: {len(constants['directories']['excluded'])}")
    print(f"  Primeros 5: {list(constants['directories']['excluded'])[:5]}")
    
    # Demostrar detecci√≥n de lenguaje usando constantes
    print("\nüîç Detecci√≥n de Lenguajes (usando constantes):")
    test_files = ['script.py', 'app.js', 'component.ts', 'Main.java', 'program.cpp']
    for file in test_files:
        language = modifier.detect_language(file)
        print(f"  {file}: {language}")
    
    # Mostrar configuraci√≥n actual
    print("\n‚öôÔ∏è Configuraci√≥n Actual:")
    config = modifier.get_config()
    important_configs = ['dry_run_mode', 'backup_enabled', 'max_file_size_mb', 'log_level']
    for key in important_configs:
        if key in config:
            print(f"  {key.replace('_', ' ').title()}: {config[key]}")
    
    # Verificar integridad de constantes
    print("\n‚úÖ Verificaci√≥n de Integridad de Constantes:")
    
    # Verificar que las extensiones tienen mapeos de lenguaje
    missing_mappings = []
    for ext in DEFAULT_SUPPORTED_EXTENSIONS:
        if ext not in EXTENSION_TO_LANGUAGE:
            missing_mappings.append(ext)
    
    if missing_mappings:
        print(f"  ‚ö†Ô∏è  Extensiones sin mapeo de lenguaje: {missing_mappings}")
    else:
        print("  ‚úÖ Todas las extensiones tienen mapeo de lenguaje")
    
    # Verificar configuraci√≥n por defecto
    try:
        test_modifier = UniversalCodeModifier(**DEFAULT_CONFIG)
        print("  ‚úÖ Configuraci√≥n por defecto es v√°lida")
    except Exception as e:
        print(f"  ‚ùå Error en configuraci√≥n por defecto: {e}")
    
    print(f"\nüéâ Demostraci√≥n de {PROJECT_NAME} v{VERSION} completada!")


if __name__ == "__main__":
    main()
