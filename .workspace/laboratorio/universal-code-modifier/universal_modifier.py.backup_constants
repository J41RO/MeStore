#!/usr/bin/env python3
"""
Universal Code Modifier
import time
Una herramienta para modificar c√≥digo de forma universal y segura.
Permite aplicar transformaciones y modificaciones a diferentes tipos de archivos de c√≥digo.

Author: Laboratorio de Desarrollo
Version: 0.1.0
"""

import os
import time
import sys
import logging
from pathlib import Path
from typing import List, Dict, Optional, Union
from abc import ABC, abstractmethod

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class UniversalCodeModifier:
    """
    Clase principal para modificaciones universales de c√≥digo.
    
    Esta clase proporciona la funcionalidad base para modificar
    archivos de c√≥digo de diferentes lenguajes de forma segura y controlada.
    """
    def __init__(self, 
                 base_path: Optional[str] = None,
                 backup_enabled: bool = True,
                 dry_run_mode: bool = False,
                 max_file_size_mb: int = 10,
                 custom_extensions: Optional[List[str]] = None,
                 excluded_dirs: Optional[List[str]] = None,
                 log_level: str = "INFO",
                 backup_dir: Optional[str] = None,
                 file_encoding: str = "utf-8",
                 validate_syntax: bool = True):
        """
        Inicializar el modificador universal de c√≥digo con configuraci√≥n avanzada.
        
        Args:
            base_path (str, optional): Ruta base para operaciones de archivos
            backup_enabled (bool): Si crear respaldos autom√°ticamente (default: True)
            dry_run_mode (bool): Modo de prueba sin modificaciones reales (default: False)
            max_file_size_mb (int): Tama√±o m√°ximo de archivo en MB (default: 10)
            custom_extensions (List[str], optional): Extensiones personalizadas adicionales
            excluded_dirs (List[str], optional): Directorios a excluir del procesamiento
            log_level (str): Nivel de logging (DEBUG, INFO, WARNING, ERROR) (default: INFO)
            backup_dir (str, optional): Directorio espec√≠fico para backups
            file_encoding (str): Encoding por defecto para archivos (default: utf-8)
            validate_syntax (bool): Si validar sintaxis antes de modificar (default: True)
            
        Raises:
            ValueError: Si los par√°metros no son v√°lidos
            FileNotFoundError: Si base_path no existe
            PermissionError: Si no hay permisos en el directorio base
        """
        # Validaci√≥n y configuraci√≥n de base_path
        if base_path:
            self.base_path = Path(base_path).resolve()
            if not self.base_path.exists():
                raise FileNotFoundError(f"El directorio base no existe: {self.base_path}")
            if not self.base_path.is_dir():
                raise ValueError(f"base_path debe ser un directorio: {self.base_path}")
            if not os.access(self.base_path, os.R_OK):
                raise PermissionError(f"Sin permisos de lectura en: {self.base_path}")
        else:
            self.base_path = Path.cwd()
        
        # Configuraci√≥n de extensiones soportadas
        self.default_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.cs', '.go', '.rs', '.php']
        if custom_extensions:
            # Validar formato de extensiones personalizadas
            validated_extensions = []
            for ext in custom_extensions:
                if not ext.startswith('.'):
                    ext = '.' + ext
                if len(ext) > 1 and ext.isascii():
                    validated_extensions.append(ext.lower())
                else:
                    self.logger.warning(f"Extensi√≥n inv√°lida ignorada: {ext}")
            self.supported_extensions = list(set(self.default_extensions + validated_extensions))
        else:
            self.supported_extensions = self.default_extensions.copy()
        
        # Configuraci√≥n de directorios excluidos
        default_excluded = {'.git', '__pycache__', 'node_modules', '.venv', 'venv', '.idea', '.vscode'}
        if excluded_dirs:
            self.excluded_dirs = default_excluded.union(set(excluded_dirs))
        else:
            self.excluded_dirs = default_excluded
        
        # Configuraci√≥n de tama√±o m√°ximo de archivo
        if max_file_size_mb <= 0:
            raise ValueError("max_file_size_mb debe ser mayor a 0")
        self.max_file_size = max_file_size_mb * 1024 * 1024  # Convertir a bytes
        
        # Configuraci√≥n de backup
        self.backup_enabled = backup_enabled
        if backup_dir:
            self.backup_dir = Path(backup_dir)
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True, exist_ok=True)
        else:
            self.backup_dir = None
        
        # Configuraci√≥n de modo de operaci√≥n
        self.dry_run_mode = dry_run_mode
        self.validate_syntax = validate_syntax
        self.file_encoding = file_encoding
        
        # Validar encoding
        try:
            "test".encode(file_encoding)
        except LookupError:
            raise ValueError(f"Encoding no v√°lido: {file_encoding}")
        
        # Configuraci√≥n de logging
        valid_log_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
        if log_level.upper() not in valid_log_levels:
            raise ValueError(f"log_level debe ser uno de: {valid_log_levels}")
        
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.logger.setLevel(getattr(logging, log_level.upper()))
        
        # Contadores y estad√≠sticas
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        
        # Configuraci√≥n adicional
        self.config = {
            'base_path': str(self.base_path),
            'backup_enabled': self.backup_enabled,
            'dry_run_mode': self.dry_run_mode,
            'max_file_size_mb': max_file_size_mb,
            'supported_extensions': self.supported_extensions,
            'excluded_dirs': list(self.excluded_dirs),
            'log_level': log_level.upper(),
            'file_encoding': self.file_encoding,
            'validate_syntax': self.validate_syntax
        }
        
        # Log de inicializaci√≥n
        self.logger.info(f"UniversalCodeModifier inicializado exitosamente")
        self.logger.info(f"Directorio base: {self.base_path}")
        self.logger.info(f"Modo dry-run: {self.dry_run_mode}")
        self.logger.info(f"Backup habilitado: {self.backup_enabled}")
        self.logger.info(f"Extensiones soportadas: {len(self.supported_extensions)} tipos")
        self.logger.debug(f"Configuraci√≥n completa: {self.config}")


    def get_config(self) -> Dict[str, any]:
        """
        Obtener la configuraci√≥n actual del modificador.
        
        Returns:
            Dict: Configuraci√≥n completa actual
        """
        current_config = self.config.copy()
        current_config.update({
            'modification_count': self.modification_count,
            'files_processed': self.files_processed,
            'errors_count': self.errors_count,
            'uptime_seconds': self._get_uptime()
        })
        return current_config
    
    def update_config(self, **kwargs) -> bool:
        """
        Actualizar configuraci√≥n en tiempo de ejecuci√≥n.
        
        Args:
            **kwargs: Par√°metros de configuraci√≥n a actualizar
            
        Returns:
            bool: True si la actualizaci√≥n fue exitosa
        """
        valid_params = {
            'backup_enabled', 'dry_run_mode', 'max_file_size_mb', 
            'log_level', 'file_encoding', 'validate_syntax'
        }
        
        updated = False
        for key, value in kwargs.items():
            if key not in valid_params:
                self.logger.warning(f"Par√°metro de configuraci√≥n inv√°lido: {key}")
                continue
                
            try:
                if key == 'max_file_size_mb':
                    if value <= 0:
                        raise ValueError("max_file_size_mb debe ser mayor a 0")
                    self.max_file_size = value * 1024 * 1024
                    self.config[key] = value
                elif key == 'log_level':
                    valid_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
                    if value.upper() not in valid_levels:
                        raise ValueError(f"log_level debe ser uno de: {valid_levels}")
                    self.logger.setLevel(getattr(logging, value.upper()))
                    self.config[key] = value.upper()
                elif key == 'file_encoding':
                    "test".encode(value)  # Validar encoding
                    setattr(self, key, value)
                    self.config[key] = value
                else:
                    setattr(self, key, value)
                    self.config[key] = value
                
                updated = True
                self.logger.info(f"Configuraci√≥n actualizada: {key} = {value}")
                
            except Exception as e:
                self.logger.error(f"Error actualizando {key}: {e}")
                return False
        
        return updated
    
    def reset_counters(self):
        """Resetear contadores de estad√≠sticas."""
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        self.logger.info("Contadores de estad√≠sticas reseteados")
    
    def validate_permissions(self) -> bool:
        """
        Validar permisos en el directorio base.
        
        Returns:
            bool: True si tiene permisos necesarios
        """
        try:
            # Verificar lectura
            if not os.access(self.base_path, os.R_OK):
                self.logger.error(f"Sin permisos de lectura en: {self.base_path}")
                return False
            
            # Verificar escritura si no es dry-run
            if not self.dry_run_mode and not os.access(self.base_path, os.W_OK):
                self.logger.error(f"Sin permisos de escritura en: {self.base_path}")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error validando permisos: {e}")
            return False
    
    def _get_uptime(self) -> float:
        """
        Calcular tiempo de vida de la instancia.
        
        Returns:
            float: Tiempo en segundos desde la inicializaci√≥n
        """
        if not self.start_time:
            self.start_time = time.time()
            return 0.0
        return time.time() - self.start_time
    
    def get_stats(self) -> Dict[str, any]:
        """
        Obtener estad√≠sticas de la sesi√≥n actual.
        
        Returns:
            Dict: Estad√≠sticas detalladas
        """
        uptime = self._get_uptime()
        return {
            'files_processed': self.files_processed,
            'modifications_made': self.modification_count,
            'errors_encountered': self.errors_count,
            'uptime_seconds': uptime,
            'uptime_formatted': f"{uptime:.2f}s",
            'success_rate': (
                (self.files_processed - self.errors_count) / max(self.files_processed, 1) * 100
                if self.files_processed > 0 else 0.0
            ),
            'avg_files_per_second': self.files_processed / max(uptime, 1) if uptime > 0 else 0.0
        }

    def validate_file(self, file_path: Union[str, Path]) -> bool:
        """
        Validar que el archivo existe y es modificable.
        
        Args:
            file_path: Ruta al archivo a validar
            
        Returns:
            bool: True si el archivo es v√°lido, False en caso contrario
        """
        path = Path(file_path)
        
        if not path.exists():
            self.logger.error(f"Archivo no encontrado: {path}")
            return False
            
        if not path.is_file():
            self.logger.error(f"La ruta no es un archivo: {path}")
            return False
            
        if path.suffix not in self.supported_extensions:
            self.logger.warning(f"Extensi√≥n no soportada: {path.suffix}")
            return False
            
        return True
    
    def create_backup(self, file_path: Union[str, Path]) -> Optional[Path]:
        """
        Crear respaldo de un archivo antes de modificarlo.
        
        Args:
            file_path: Ruta al archivo original
            
        Returns:
            Path: Ruta al archivo de respaldo creado, None si falla
        """
        if not self.backup_enabled:
            return None
            
        original_path = Path(file_path)
        backup_path = original_path.with_suffix(f"{original_path.suffix}.backup")
        
        try:
            backup_path.write_text(original_path.read_text(encoding='utf-8'))
            self.logger.info(f"Backup creado: {backup_path}")
            return backup_path
        except Exception as e:
            self.logger.error(f"Error creando backup: {e}")
            return None
    
    def list_files(self, directory: Optional[Union[str, Path]] = None, 
                   recursive: bool = True) -> List[Path]:
        """
        Listar archivos de c√≥digo en un directorio.
        
        Args:
            directory: Directorio a escanear (por defecto: base_path)
            recursive: Si buscar recursivamente en subdirectorios
            
        Returns:
            List[Path]: Lista de archivos encontrados
        """
        search_path = Path(directory) if directory else self.base_path
        found_files = []
        
        try:
            if recursive:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.rglob(f"*{ext}"))
            else:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.glob(f"*{ext}"))
                    
            self.logger.info(f"Encontrados {len(found_files)} archivos en {search_path}")
            return sorted(found_files)
            
        except Exception as e:
            self.logger.error(f"Error listando archivos: {e}")
            return []


    def detect_language(self, file_path: Union[str, Path]) -> Optional[str]:
        """
        Detectar el lenguaje de programaci√≥n basado en la extensi√≥n del archivo.
        """
        path = Path(file_path)
        extension_map = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.java': 'Java'
        }
        return extension_map.get(path.suffix.lower())

    def analyze_file_metrics(self, file_path: Union[str, Path]) -> Dict[str, int]:
        """
        Analizar m√©tricas b√°sicas de un archivo de c√≥digo.
        """
        content = self.read_file_safe(file_path) if hasattr(self, 'read_file_safe') else None
        if not content:
            try:
                content = Path(file_path).read_text()
            except:
                return {}
        lines = content.split('\n')
        return {
            'total_lines': len(lines),
            'non_empty_lines': len([line for line in lines if line.strip()]),
            'total_characters': len(content)
        }


def main():
    """Funci√≥n principal para pruebas y demostraci√≥n de configuraci√≥n avanzada."""
    print("Universal Code Modifier v0.1.2")
    print("Herramienta de modificaci√≥n universal de c√≥digo")
    print("=" * 60)
    
    # Demostrar configuraci√≥n b√°sica
    print("\nüîß Configuraci√≥n B√°sica:")
    modifier = UniversalCodeModifier()
    print(f"Directorio base: {modifier.base_path}")
    print(f"Extensiones soportadas: {len(modifier.supported_extensions)}")
    
    # Demostrar configuraci√≥n avanzada
    print("\nüöÄ Configuraci√≥n Avanzada:")
    advanced_modifier = UniversalCodeModifier(
        dry_run_mode=True,
        max_file_size_mb=5,
        log_level="DEBUG",
        custom_extensions=[".md", ".txt"],
        excluded_dirs=["temp", "cache"]
    )
    
    config = advanced_modifier.get_config()
    print(f"Modo dry-run: {config['dry_run_mode']}")
    print(f"Tama√±o m√°ximo: {config['max_file_size_mb']}MB")
    print(f"Extensiones totales: {len(config['supported_extensions'])}")
    print(f"Directorios excluidos: {len(config['excluded_dirs'])}")
    
    # Demostrar actualizaci√≥n de configuraci√≥n
    print("\n‚öôÔ∏è Actualizaci√≥n de Configuraci√≥n:")
    success = advanced_modifier.update_config(
        backup_enabled=False,
        max_file_size_mb=20
    )
    print(f"Actualizaci√≥n exitosa: {success}")
    
    # Mostrar estad√≠sticas
    print("\nüìä Estad√≠sticas:")
    stats = advanced_modifier.get_stats()
    for key, value in stats.items():
        print(f"  {key}: {value}")
    
    # Validar permisos
    print("\nüîí Validaci√≥n de Permisos:")
    has_permissions = advanced_modifier.validate_permissions()
    print(f"Permisos v√°lidos: {has_permissions}")
    
    # Analizar archivo actual si existe
    current_file = Path(__file__)
    if current_file.exists():
        print(f"\nüìÑ An√°lisis del archivo actual: {current_file.name}")
        
        # Detectar lenguaje (si el m√©todo existe)
        if hasattr(advanced_modifier, 'detect_language'):
            language = advanced_modifier.detect_language(current_file)
            print(f"Lenguaje detectado: {language}")
        
        # Validar archivo
        is_valid = advanced_modifier.validate_file(current_file)
        print(f"Archivo v√°lido: {is_valid}")
    
    print("\n‚úÖ Demostraci√≥n de configuraci√≥n completada!")


if __name__ == "__main__":
    main()
