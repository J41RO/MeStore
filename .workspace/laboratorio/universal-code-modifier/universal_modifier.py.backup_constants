#!/usr/bin/env python3
"""
Universal Code Modifier
import time
Una herramienta para modificar código de forma universal y segura.
Permite aplicar transformaciones y modificaciones a diferentes tipos de archivos de código.

Author: Laboratorio de Desarrollo
Version: 0.1.0
"""

import os
import time
import sys
import logging
from pathlib import Path
from typing import List, Dict, Optional, Union
from abc import ABC, abstractmethod

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


class UniversalCodeModifier:
    """
    Clase principal para modificaciones universales de código.
    
    Esta clase proporciona la funcionalidad base para modificar
    archivos de código de diferentes lenguajes de forma segura y controlada.
    """
    def __init__(self, 
                 base_path: Optional[str] = None,
                 backup_enabled: bool = True,
                 dry_run_mode: bool = False,
                 max_file_size_mb: int = 10,
                 custom_extensions: Optional[List[str]] = None,
                 excluded_dirs: Optional[List[str]] = None,
                 log_level: str = "INFO",
                 backup_dir: Optional[str] = None,
                 file_encoding: str = "utf-8",
                 validate_syntax: bool = True):
        """
        Inicializar el modificador universal de código con configuración avanzada.
        
        Args:
            base_path (str, optional): Ruta base para operaciones de archivos
            backup_enabled (bool): Si crear respaldos automáticamente (default: True)
            dry_run_mode (bool): Modo de prueba sin modificaciones reales (default: False)
            max_file_size_mb (int): Tamaño máximo de archivo en MB (default: 10)
            custom_extensions (List[str], optional): Extensiones personalizadas adicionales
            excluded_dirs (List[str], optional): Directorios a excluir del procesamiento
            log_level (str): Nivel de logging (DEBUG, INFO, WARNING, ERROR) (default: INFO)
            backup_dir (str, optional): Directorio específico para backups
            file_encoding (str): Encoding por defecto para archivos (default: utf-8)
            validate_syntax (bool): Si validar sintaxis antes de modificar (default: True)
            
        Raises:
            ValueError: Si los parámetros no son válidos
            FileNotFoundError: Si base_path no existe
            PermissionError: Si no hay permisos en el directorio base
        """
        # Validación y configuración de base_path
        if base_path:
            self.base_path = Path(base_path).resolve()
            if not self.base_path.exists():
                raise FileNotFoundError(f"El directorio base no existe: {self.base_path}")
            if not self.base_path.is_dir():
                raise ValueError(f"base_path debe ser un directorio: {self.base_path}")
            if not os.access(self.base_path, os.R_OK):
                raise PermissionError(f"Sin permisos de lectura en: {self.base_path}")
        else:
            self.base_path = Path.cwd()
        
        # Configuración de extensiones soportadas
        self.default_extensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.cs', '.go', '.rs', '.php']
        if custom_extensions:
            # Validar formato de extensiones personalizadas
            validated_extensions = []
            for ext in custom_extensions:
                if not ext.startswith('.'):
                    ext = '.' + ext
                if len(ext) > 1 and ext.isascii():
                    validated_extensions.append(ext.lower())
                else:
                    self.logger.warning(f"Extensión inválida ignorada: {ext}")
            self.supported_extensions = list(set(self.default_extensions + validated_extensions))
        else:
            self.supported_extensions = self.default_extensions.copy()
        
        # Configuración de directorios excluidos
        default_excluded = {'.git', '__pycache__', 'node_modules', '.venv', 'venv', '.idea', '.vscode'}
        if excluded_dirs:
            self.excluded_dirs = default_excluded.union(set(excluded_dirs))
        else:
            self.excluded_dirs = default_excluded
        
        # Configuración de tamaño máximo de archivo
        if max_file_size_mb <= 0:
            raise ValueError("max_file_size_mb debe ser mayor a 0")
        self.max_file_size = max_file_size_mb * 1024 * 1024  # Convertir a bytes
        
        # Configuración de backup
        self.backup_enabled = backup_enabled
        if backup_dir:
            self.backup_dir = Path(backup_dir)
            if not self.backup_dir.exists():
                self.backup_dir.mkdir(parents=True, exist_ok=True)
        else:
            self.backup_dir = None
        
        # Configuración de modo de operación
        self.dry_run_mode = dry_run_mode
        self.validate_syntax = validate_syntax
        self.file_encoding = file_encoding
        
        # Validar encoding
        try:
            "test".encode(file_encoding)
        except LookupError:
            raise ValueError(f"Encoding no válido: {file_encoding}")
        
        # Configuración de logging
        valid_log_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
        if log_level.upper() not in valid_log_levels:
            raise ValueError(f"log_level debe ser uno de: {valid_log_levels}")
        
        self.logger = logging.getLogger(f"{__name__}.{self.__class__.__name__}")
        self.logger.setLevel(getattr(logging, log_level.upper()))
        
        # Contadores y estadísticas
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        
        # Configuración adicional
        self.config = {
            'base_path': str(self.base_path),
            'backup_enabled': self.backup_enabled,
            'dry_run_mode': self.dry_run_mode,
            'max_file_size_mb': max_file_size_mb,
            'supported_extensions': self.supported_extensions,
            'excluded_dirs': list(self.excluded_dirs),
            'log_level': log_level.upper(),
            'file_encoding': self.file_encoding,
            'validate_syntax': self.validate_syntax
        }
        
        # Log de inicialización
        self.logger.info(f"UniversalCodeModifier inicializado exitosamente")
        self.logger.info(f"Directorio base: {self.base_path}")
        self.logger.info(f"Modo dry-run: {self.dry_run_mode}")
        self.logger.info(f"Backup habilitado: {self.backup_enabled}")
        self.logger.info(f"Extensiones soportadas: {len(self.supported_extensions)} tipos")
        self.logger.debug(f"Configuración completa: {self.config}")


    def get_config(self) -> Dict[str, any]:
        """
        Obtener la configuración actual del modificador.
        
        Returns:
            Dict: Configuración completa actual
        """
        current_config = self.config.copy()
        current_config.update({
            'modification_count': self.modification_count,
            'files_processed': self.files_processed,
            'errors_count': self.errors_count,
            'uptime_seconds': self._get_uptime()
        })
        return current_config
    
    def update_config(self, **kwargs) -> bool:
        """
        Actualizar configuración en tiempo de ejecución.
        
        Args:
            **kwargs: Parámetros de configuración a actualizar
            
        Returns:
            bool: True si la actualización fue exitosa
        """
        valid_params = {
            'backup_enabled', 'dry_run_mode', 'max_file_size_mb', 
            'log_level', 'file_encoding', 'validate_syntax'
        }
        
        updated = False
        for key, value in kwargs.items():
            if key not in valid_params:
                self.logger.warning(f"Parámetro de configuración inválido: {key}")
                continue
                
            try:
                if key == 'max_file_size_mb':
                    if value <= 0:
                        raise ValueError("max_file_size_mb debe ser mayor a 0")
                    self.max_file_size = value * 1024 * 1024
                    self.config[key] = value
                elif key == 'log_level':
                    valid_levels = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
                    if value.upper() not in valid_levels:
                        raise ValueError(f"log_level debe ser uno de: {valid_levels}")
                    self.logger.setLevel(getattr(logging, value.upper()))
                    self.config[key] = value.upper()
                elif key == 'file_encoding':
                    "test".encode(value)  # Validar encoding
                    setattr(self, key, value)
                    self.config[key] = value
                else:
                    setattr(self, key, value)
                    self.config[key] = value
                
                updated = True
                self.logger.info(f"Configuración actualizada: {key} = {value}")
                
            except Exception as e:
                self.logger.error(f"Error actualizando {key}: {e}")
                return False
        
        return updated
    
    def reset_counters(self):
        """Resetear contadores de estadísticas."""
        self.modification_count = 0
        self.files_processed = 0
        self.errors_count = 0
        self.start_time = None
        self.logger.info("Contadores de estadísticas reseteados")
    
    def validate_permissions(self) -> bool:
        """
        Validar permisos en el directorio base.
        
        Returns:
            bool: True si tiene permisos necesarios
        """
        try:
            # Verificar lectura
            if not os.access(self.base_path, os.R_OK):
                self.logger.error(f"Sin permisos de lectura en: {self.base_path}")
                return False
            
            # Verificar escritura si no es dry-run
            if not self.dry_run_mode and not os.access(self.base_path, os.W_OK):
                self.logger.error(f"Sin permisos de escritura en: {self.base_path}")
                return False
            
            return True
            
        except Exception as e:
            self.logger.error(f"Error validando permisos: {e}")
            return False
    
    def _get_uptime(self) -> float:
        """
        Calcular tiempo de vida de la instancia.
        
        Returns:
            float: Tiempo en segundos desde la inicialización
        """
        if not self.start_time:
            self.start_time = time.time()
            return 0.0
        return time.time() - self.start_time
    
    def get_stats(self) -> Dict[str, any]:
        """
        Obtener estadísticas de la sesión actual.
        
        Returns:
            Dict: Estadísticas detalladas
        """
        uptime = self._get_uptime()
        return {
            'files_processed': self.files_processed,
            'modifications_made': self.modification_count,
            'errors_encountered': self.errors_count,
            'uptime_seconds': uptime,
            'uptime_formatted': f"{uptime:.2f}s",
            'success_rate': (
                (self.files_processed - self.errors_count) / max(self.files_processed, 1) * 100
                if self.files_processed > 0 else 0.0
            ),
            'avg_files_per_second': self.files_processed / max(uptime, 1) if uptime > 0 else 0.0
        }

    def validate_file(self, file_path: Union[str, Path]) -> bool:
        """
        Validar que el archivo existe y es modificable.
        
        Args:
            file_path: Ruta al archivo a validar
            
        Returns:
            bool: True si el archivo es válido, False en caso contrario
        """
        path = Path(file_path)
        
        if not path.exists():
            self.logger.error(f"Archivo no encontrado: {path}")
            return False
            
        if not path.is_file():
            self.logger.error(f"La ruta no es un archivo: {path}")
            return False
            
        if path.suffix not in self.supported_extensions:
            self.logger.warning(f"Extensión no soportada: {path.suffix}")
            return False
            
        return True
    
    def create_backup(self, file_path: Union[str, Path]) -> Optional[Path]:
        """
        Crear respaldo de un archivo antes de modificarlo.
        
        Args:
            file_path: Ruta al archivo original
            
        Returns:
            Path: Ruta al archivo de respaldo creado, None si falla
        """
        if not self.backup_enabled:
            return None
            
        original_path = Path(file_path)
        backup_path = original_path.with_suffix(f"{original_path.suffix}.backup")
        
        try:
            backup_path.write_text(original_path.read_text(encoding='utf-8'))
            self.logger.info(f"Backup creado: {backup_path}")
            return backup_path
        except Exception as e:
            self.logger.error(f"Error creando backup: {e}")
            return None
    
    def list_files(self, directory: Optional[Union[str, Path]] = None, 
                   recursive: bool = True) -> List[Path]:
        """
        Listar archivos de código en un directorio.
        
        Args:
            directory: Directorio a escanear (por defecto: base_path)
            recursive: Si buscar recursivamente en subdirectorios
            
        Returns:
            List[Path]: Lista de archivos encontrados
        """
        search_path = Path(directory) if directory else self.base_path
        found_files = []
        
        try:
            if recursive:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.rglob(f"*{ext}"))
            else:
                for ext in self.supported_extensions:
                    found_files.extend(search_path.glob(f"*{ext}"))
                    
            self.logger.info(f"Encontrados {len(found_files)} archivos en {search_path}")
            return sorted(found_files)
            
        except Exception as e:
            self.logger.error(f"Error listando archivos: {e}")
            return []


    def detect_language(self, file_path: Union[str, Path]) -> Optional[str]:
        """
        Detectar el lenguaje de programación basado en la extensión del archivo.
        """
        path = Path(file_path)
        extension_map = {
            '.py': 'Python',
            '.js': 'JavaScript',
            '.java': 'Java'
        }
        return extension_map.get(path.suffix.lower())

    def analyze_file_metrics(self, file_path: Union[str, Path]) -> Dict[str, int]:
        """
        Analizar métricas básicas de un archivo de código.
        """
        content = self.read_file_safe(file_path) if hasattr(self, 'read_file_safe') else None
        if not content:
            try:
                content = Path(file_path).read_text()
            except:
                return {}
        lines = content.split('\n')
        return {
            'total_lines': len(lines),
            'non_empty_lines': len([line for line in lines if line.strip()]),
            'total_characters': len(content)
        }


def main():
    """Función principal para pruebas y demostración de configuración avanzada."""
    print("Universal Code Modifier v0.1.2")
    print("Herramienta de modificación universal de código")
    print("=" * 60)
    
    # Demostrar configuración básica
    print("\n🔧 Configuración Básica:")
    modifier = UniversalCodeModifier()
    print(f"Directorio base: {modifier.base_path}")
    print(f"Extensiones soportadas: {len(modifier.supported_extensions)}")
    
    # Demostrar configuración avanzada
    print("\n🚀 Configuración Avanzada:")
    advanced_modifier = UniversalCodeModifier(
        dry_run_mode=True,
        max_file_size_mb=5,
        log_level="DEBUG",
        custom_extensions=[".md", ".txt"],
        excluded_dirs=["temp", "cache"]
    )
    
    config = advanced_modifier.get_config()
    print(f"Modo dry-run: {config['dry_run_mode']}")
    print(f"Tamaño máximo: {config['max_file_size_mb']}MB")
    print(f"Extensiones totales: {len(config['supported_extensions'])}")
    print(f"Directorios excluidos: {len(config['excluded_dirs'])}")
    
    # Demostrar actualización de configuración
    print("\n⚙️ Actualización de Configuración:")
    success = advanced_modifier.update_config(
        backup_enabled=False,
        max_file_size_mb=20
    )
    print(f"Actualización exitosa: {success}")
    
    # Mostrar estadísticas
    print("\n📊 Estadísticas:")
    stats = advanced_modifier.get_stats()
    for key, value in stats.items():
        print(f"  {key}: {value}")
    
    # Validar permisos
    print("\n🔒 Validación de Permisos:")
    has_permissions = advanced_modifier.validate_permissions()
    print(f"Permisos válidos: {has_permissions}")
    
    # Analizar archivo actual si existe
    current_file = Path(__file__)
    if current_file.exists():
        print(f"\n📄 Análisis del archivo actual: {current_file.name}")
        
        # Detectar lenguaje (si el método existe)
        if hasattr(advanced_modifier, 'detect_language'):
            language = advanced_modifier.detect_language(current_file)
            print(f"Lenguaje detectado: {language}")
        
        # Validar archivo
        is_valid = advanced_modifier.validate_file(current_file)
        print(f"Archivo válido: {is_valid}")
    
    print("\n✅ Demostración de configuración completada!")


if __name__ == "__main__":
    main()
