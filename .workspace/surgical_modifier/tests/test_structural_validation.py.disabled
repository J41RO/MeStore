import pytest
import tempfile
import os
import shutil
from unittest.mock import patch, MagicMock

from core.functions.validation import (
    StructuralValidator,
    RollbackManager,
    validate_structural_integrity,
    StructuralIntegrityError,
    manual_structural_validation
)


class TestStructuralValidator:
    """Tests para la clase StructuralValidator."""
    
    def setup_method(self):
        """Configuración antes de cada test."""
        self.validator = StructuralValidator()
        self.temp_dir = tempfile.mkdtemp()
    
    def teardown_method(self):
        """Limpieza después de cada test."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_validate_python_syntax_valid_file(self):
        """Test validación de sintaxis con archivo válido."""
        test_file = os.path.join(self.temp_dir, 'valid.py')
        with open(test_file, 'w') as f:
            f.write('def hello_world():\n    return "Hello, World!"\n')
        
        is_valid, error = self.validator.validate_python_syntax(test_file)
        assert is_valid is True
        assert error is None
    
    def test_validate_python_syntax_invalid_file(self):
        """Test validación de sintaxis con archivo inválido."""
        test_file = os.path.join(self.temp_dir, 'invalid.py')
        with open(test_file, 'w') as f:
            f.write('def broken_function(\n    # Sintaxis rota')
        
        is_valid, error = self.validator.validate_python_syntax(test_file)
        assert is_valid is False
        assert error is not None
        assert 'was never closed' in error
    
    def test_validate_python_syntax_nonexistent_file(self):
        """Test validación de sintaxis con archivo inexistente."""
        nonexistent_file = os.path.join(self.temp_dir, 'nonexistent.py')
        
        is_valid, error = self.validator.validate_python_syntax(nonexistent_file)
        assert is_valid is False
        assert 'Archivo no encontrado' in error
    
    def test_validate_indentation_consistent(self):
        """Test validación de indentación consistente."""
        test_file = os.path.join(self.temp_dir, 'consistent.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n    if True:\n        return True\n    else:\n        return False\n')
        
        is_consistent, issues = self.validator.validate_indentation(test_file)
        assert is_consistent is True
        assert len(issues) == 0
    
    def test_validate_indentation_inconsistent(self):
        """Test validación de indentación inconsistente."""
        test_file = os.path.join(self.temp_dir, 'inconsistent.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n  if True:\n      return True\n')  # 2 y 6 espacios
        
        is_consistent, issues = self.validator.validate_indentation(test_file)
        assert is_consistent is False
        assert len(issues) > 0
    
    def test_analyze_structure_complete_file(self):
        """Test análisis de estructura con archivo completo."""
        test_file = os.path.join(self.temp_dir, 'complete.py')
        with open(test_file, 'w') as f:
            f.write('''import os
from typing import List

class TestClass:
    def __init__(self):
        pass
    
    def method1(self):
        return True

def function1(arg1, arg2):
    return arg1 + arg2
''')
        
        structure = self.validator.analyze_structure(test_file)
        assert 'classes' in structure
        assert 'functions' in structure
        assert 'imports' in structure
        assert len(structure['classes']) == 1
        assert len(structure['functions']) == 3  # Incluye __init__, method1, function1
        assert structure['classes'][0]['name'] == 'TestClass'
        assert len(structure['classes'][0]['methods']) == 2
    
    def test_detect_incomplete_constructs_empty_class(self):
        """Test detección de clases vacías."""
        test_file = os.path.join(self.temp_dir, 'empty_class.py')
        with open(test_file, 'w') as f:
            f.write('class EmptyClass:\n    pass\n')
        
        issues = self.validator.detect_incomplete_constructs(test_file)
        assert len(issues) == 1
        assert issues[0]['type'] == 'empty_class'
    
    def test_detect_incomplete_constructs_empty_function(self):
        """Test detección de funciones vacías."""
        test_file = os.path.join(self.temp_dir, 'empty_function.py')
        with open(test_file, 'w') as f:
            f.write('def empty_function():\n    pass\n')
        
        issues = self.validator.detect_incomplete_constructs(test_file)
        assert len(issues) == 1
        assert issues[0]['type'] == 'empty_function'
    
    def test_detect_incomplete_constructs_ellipsis_function(self):
        """Test detección de funciones con ellipsis."""
        test_file = os.path.join(self.temp_dir, 'ellipsis_function.py')
        with open(test_file, 'w') as f:
            f.write('def ellipsis_function():\n    ...\n')
        
        issues = self.validator.detect_incomplete_constructs(test_file)
        assert len(issues) == 1
        assert issues[0]['type'] == 'ellipsis_function'


class TestRollbackManager:
    """Tests para la clase RollbackManager."""
    
    def setup_method(self):
        """Configuración antes de cada test."""
        self.manager = RollbackManager()
        self.temp_dir = tempfile.mkdtemp()
    
    def teardown_method(self):
        """Limpieza después de cada test."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_create_checkpoint_success(self):
        """Test creación exitosa de checkpoint."""
        test_file = os.path.join(self.temp_dir, 'test.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n    return True\n')
        
        checkpoint = self.manager.create_checkpoint(test_file)
        assert checkpoint is not None
        assert 'id' in checkpoint
        assert 'checkpoint_path' in checkpoint
        assert os.path.exists(checkpoint['checkpoint_path'])
    
    def test_create_checkpoint_nonexistent_file(self):
        """Test creación de checkpoint con archivo inexistente."""
        nonexistent_file = os.path.join(self.temp_dir, 'nonexistent.py')
        
        checkpoint = self.manager.create_checkpoint(nonexistent_file)
        assert checkpoint is None
    
    def test_rollback_to_checkpoint_success(self):
        """Test rollback exitoso."""
        test_file = os.path.join(self.temp_dir, 'test.py')
        original_content = 'def original():\n    return "original"\n'
        modified_content = 'def modified():\n    return "modified"\n'
        
        # Crear archivo original
        with open(test_file, 'w') as f:
            f.write(original_content)
        
        # Crear checkpoint
        checkpoint = self.manager.create_checkpoint(test_file)
        
        # Modificar archivo
        with open(test_file, 'w') as f:
            f.write(modified_content)
        
        # Rollback
        success = self.manager.rollback_to_checkpoint(test_file, checkpoint)
        assert success is True
        
        # Verificar contenido restaurado
        with open(test_file, 'r') as f:
            content = f.read()
        assert content == original_content
    
    def test_rollback_to_checkpoint_invalid_checkpoint(self):
        """Test rollback con checkpoint inválido."""
        test_file = os.path.join(self.temp_dir, 'test.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n    return True\n')
        
        success = self.manager.rollback_to_checkpoint(test_file, None)
        assert success is False
    
    def test_validate_file_integrity(self):
        """Test validación de integridad de archivo."""
        test_file = os.path.join(self.temp_dir, 'test.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n    return True\n')
        
        # Sin hash esperado
        is_valid = self.manager.validate_file_integrity(test_file)
        assert is_valid is True
        
        # Con hash correcto
        file_hash = self.manager._calculate_file_hash(test_file)
        is_valid = self.manager.validate_file_integrity(test_file, file_hash)
        assert is_valid is True
        
        # Con hash incorrecto
        is_valid = self.manager.validate_file_integrity(test_file, 'wrong_hash')
        assert is_valid is False


class TestIntegrationValidator:
    """Tests para el decorador de validación integrada."""
    
    def setup_method(self):
        """Configuración antes de cada test."""
        self.temp_dir = tempfile.mkdtemp()
    
    def teardown_method(self):
        """Limpieza después de cada test."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_decorator_with_valid_operation(self):
        """Test decorador con operación válida."""
        @validate_structural_integrity
        def valid_operation(file_path, content):
            with open(file_path, 'w') as f:
                f.write(content)
            return True
        
        test_file = os.path.join(self.temp_dir, 'test.py')
        result = valid_operation(test_file, 'def valid():\n    return True\n')
        assert result is True
    
    def test_decorator_with_corrupting_operation(self):
        """Test decorador con operación que corrompe el archivo."""
        @validate_structural_integrity
        def corrupting_operation(file_path, content):
            with open(file_path, 'w') as f:
                f.write(content)
            return True
        
        test_file = os.path.join(self.temp_dir, 'test.py')
        
        # Crear archivo inicial válido
        with open(test_file, 'w') as f:
            f.write('def initial():\n    return True\n')
        
        # Intentar operación que corrompe
        with pytest.raises(StructuralIntegrityError):
            corrupting_operation(test_file, 'def broken(\n    # Sintaxis rota')
        
        # Verificar que el archivo fue restaurado
        with open(test_file, 'r') as f:
            content = f.read()
        assert 'def initial():' in content
    
    def test_manual_structural_validation(self):
        """Test validación estructural manual."""
        test_file = os.path.join(self.temp_dir, 'test.py')
        with open(test_file, 'w') as f:
            f.write('def test_function():\n    pass\n')
        
        result = manual_structural_validation(test_file)
        assert 'syntax' in result
        assert 'indentation' in result
        assert 'structure' in result
        assert 'incomplete_constructs' in result
        assert result['syntax']['valid'] is True
        assert len(result['incomplete_constructs']) == 1  # función vacía


class TestEdgeCases:
    """Tests para casos edge y manejo de errores."""
    
    def setup_method(self):
        """Configuración antes de cada test."""
        self.temp_dir = tempfile.mkdtemp()
    
    def teardown_method(self):
        """Limpieza después de cada test."""
        shutil.rmtree(self.temp_dir, ignore_errors=True)
    
    def test_permission_denied_file(self):
        """Test con archivo sin permisos de lectura."""
        test_file = os.path.join(self.temp_dir, 'no_permission.py')
        with open(test_file, 'w') as f:
            f.write('def test():\n    return True\n')
        
        # Quitar permisos de lectura
        os.chmod(test_file, 0o000)
        
        try:
            validator = StructuralValidator()
            is_valid, error = validator.validate_python_syntax(test_file)
            # Dependiendo del sistema, podría fallar por permisos o pasar
            assert isinstance(is_valid, bool)
        finally:
            # Restaurar permisos para limpieza
            os.chmod(test_file, 0o644)
    
    def test_empty_file(self):
        """Test con archivo vacío."""
        test_file = os.path.join(self.temp_dir, 'empty.py')
        with open(test_file, 'w') as f:
            pass  # Archivo vacío
        
        validator = StructuralValidator()
        is_valid, error = validator.validate_python_syntax(test_file)
        assert is_valid is True  # Archivo vacío es sintácticamente válido
        
        structure = validator.analyze_structure(test_file)
        assert len(structure['classes']) == 0
        assert len(structure['functions']) == 0
    
    def test_large_file_performance(self):
        """Test con archivo grande para verificar performance."""
        test_file = os.path.join(self.temp_dir, 'large.py')
        with open(test_file, 'w') as f:
            # Generar archivo con muchas funciones
            for i in range(100):
                f.write(f'def function_{i}():\n    return {i}\n\n')
        
        validator = StructuralValidator()
        structure = validator.analyze_structure(test_file)
        assert len(structure['functions']) == 100
        
        issues = validator.detect_incomplete_constructs(test_file)
        assert len(issues) == 0  # Todas las funciones tienen contenido