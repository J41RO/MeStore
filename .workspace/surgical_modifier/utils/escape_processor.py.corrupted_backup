#!/usr/bin/env python3
"""
EscapeProcessor - Procesador mejorado para escape de caracteres
Integrado con SmartContentProcessor para máxima eficiencia
"""
import re

# Typing imports cleaned for pre-commit

try:
    from utils.smart_content_processor import SmartContentProcessor

    SMART_PROCESSOR_AVAILABLE = True
except ImportError:
    SMART_PROCESSOR_AVAILABLE = False

try:
    from utils.logger import get_logger

    logger = get_logger(__name__)
except ImportError:
    import logging

    logger = logging.getLogger(__name__)


def process_content_escapes(content):
    """
    Función principal para procesar escapes de contenido.
    Usa SmartContentProcessor si está disponible, fallback a regex básico.

    Args:
        content (str): Content with potential escape sequences
    Returns:
        str: Content with properly processed escape sequences
    """
    if not content:
        return content
    
    def fix_escape_issues(self, content: str, issue_type: str) -> str:
        """Corrige problemas específicos de escape"""
        if not content:
            return content

        # Manejar tipos específicos de problemas
        if issue_type == "double_escape":
            # Corregir escapes dobles como \\\\n -> \n
            content = content.replace("\\\\n", "\n")
            content = content.replace("\\\\t", "\t")
            content = content.replace("\\\\\\\\", "\\")
            
        elif issue_type == "broken_json_escape":
            # Corregir escapes de JSON rotos como \\"quotes\\" -> "quotes"
            content = content.replace('\\"', '"')
            
        elif issue_type == "literal_escapes" or issue_type == "all":
            # Corregir escapes literales usando patrones avanzados
            content = self.advanced_patterns["tab_literals"].sub('\t', content)
            content = self.advanced_patterns["quote_literals"].sub('"', content)
            content = self.advanced_patterns["single_quote_literals"].sub("'", content)
            content = self.advanced_patterns["newline_literals"].sub('\n', content)
            
        # Delegar al SmartContentProcessor si está disponible para casos complejos
        elif SMART_PROCESSOR_AVAILABLE:
            try:
                return SmartContentProcessor.smart_content_processing(
                    content, issue_type
                )
            except Exception as e:
                self.logger.warning(f"SmartContentProcessor failed: {e}")
                # Fallback básico
                return process_content_escapes(content)
        else:
            # Fallback básico para tipos no reconocidos
            return process_content_escapes(content)
            
        return content

    def suggest_escape_corrections(self, content: str) -> list:
        """Sugerir correcciones para problemas de escape"""
        suggestions = []

        if not content:
            return suggestions

        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)

            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_newlines",
                    "description": "Double escaped newlines detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_tabs",
                    "description": "Double escaped tabs detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions.append({
                    "issue": "escaped_quotes",
                    "description": "Escaped quotes detected",
                    "correction": "Use fix_escape_issues with 'broken_json_escape' type"
                })

            # Sugerencias específicas para el test extendido
            if '\\t' in content:
                suggestions.append({
                    "issue": "tab_escapes",
                    "description": "Tab escape literals detected",
                    "correction": "Use fix_escape_issues with 'literal_escapes' type"
                })

        except Exception as e:
            suggestions.append({
                "issue": "analysis_error",
                "description": f"Analysis error: {e}",
                "correction": "Manual review recommended"
            })

        return suggestions

    def validate_escape_integrity(self, content: str) -> dict:
        """Validar la integridad de los escapes en el contenido"""
        validation = {
            "is_valid": True,
            "issues": [],
            "errors": [],
            "warnings": [],
            "total_escapes": 0
        }
        
        if not content:
            return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions
            
        try:
            # Analizar patrones usando el método existente
            analysis = self.analyze_escape_patterns(content)
            validation["total_escapes"] = analysis.get("total_escapes", 0)
            
            # Detectar problemas comunes
            if "\\\\n" in content:
                validation["issues"].append("Double escaped newlines detected")
                validation["is_valid"] = False
                
            if "\\\\t" in content:
                validation["issues"].append("Double escaped tabs detected")
                validation["is_valid"] = False
                
            if '\\"' in content and content.count('\\"') > content.count('"'):
                validation["warnings"].append("Possible over-escaped quotes")
                
            # Verificar balance de quotes
            single_quotes = content.count("'")
            double_quotes = content.count('"')
            escaped_single = content.count("\\\'")
            escaped_double = content.count('\\"')
            
            if escaped_single > single_quotes:
                validation["warnings"].append("More escaped single quotes than regular ones")
                
            if escaped_double > double_quotes:
                validation["warnings"].append("More escaped double quotes than regular ones")
                
        except Exception as e:
            validation["is_valid"] = False
            validation["issues"].append(f"Validation error: {e}")
            
        return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions

    # Usar SmartContentProcessor si está disponible
    if SMART_PROCESSOR_AVAILABLE:
        try:
            return SmartContentProcessor.smart_content_processing(content, "general")
        except Exception as e:
            logger.warning(f"SmartContentProcessor failed, using fallback: {e}")

    # Fallback: procesamiento básico con regex
    try:
        # Convertir escapes básicos
        processed = re.sub(r"(?<!\\)\\n", "\n", content)
        processed = re.sub(r"(?<!\\)\\t", "\t", processed)
        processed = re.sub(r"(?<!\\)\\'", "'", processed)
        processed = re.sub(r'(?<!\\)\\"', '"', processed)
        return processed
    except Exception as e:
        logger.error(f"Error in fallback processing: {e}")
        return content
    
    def fix_escape_issues(self, content: str, issue_type: str) -> str:
        """Corrige problemas específicos de escape"""
        if not content:
            return content

        # Manejar tipos específicos de problemas
        if issue_type == "double_escape":
            # Corregir escapes dobles como \\\\n -> \n
            content = content.replace("\\\\n", "\n")
            content = content.replace("\\\\t", "\t")
            content = content.replace("\\\\\\\\", "\\")
            
        elif issue_type == "broken_json_escape":
            # Corregir escapes de JSON rotos como \\"quotes\\" -> "quotes"
            content = content.replace('\\"', '"')
            
        elif issue_type == "literal_escapes" or issue_type == "all":
            # Corregir escapes literales usando patrones avanzados
            content = self.advanced_patterns["tab_literals"].sub('\t', content)
            content = self.advanced_patterns["quote_literals"].sub('"', content)
            content = self.advanced_patterns["single_quote_literals"].sub("'", content)
            content = self.advanced_patterns["newline_literals"].sub('\n', content)
            
        # Delegar al SmartContentProcessor si está disponible para casos complejos
        elif SMART_PROCESSOR_AVAILABLE:
            try:
                return SmartContentProcessor.smart_content_processing(
                    content, issue_type
                )
            except Exception as e:
                self.logger.warning(f"SmartContentProcessor failed: {e}")
                # Fallback básico
                return process_content_escapes(content)
        else:
            # Fallback básico para tipos no reconocidos
            return process_content_escapes(content)
            
        return content

    def suggest_escape_corrections(self, content: str) -> list:
        """Sugerir correcciones para problemas de escape"""
        suggestions = []

        if not content:
            return suggestions

        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)

            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_newlines",
                    "description": "Double escaped newlines detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_tabs",
                    "description": "Double escaped tabs detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions.append({
                    "issue": "escaped_quotes",
                    "description": "Escaped quotes detected",
                    "correction": "Use fix_escape_issues with 'broken_json_escape' type"
                })

            # Sugerencias específicas para el test extendido
            if '\\t' in content:
                suggestions.append({
                    "issue": "tab_escapes",
                    "description": "Tab escape literals detected",
                    "correction": "Use fix_escape_issues with 'literal_escapes' type"
                })

        except Exception as e:
            suggestions.append({
                "issue": "analysis_error",
                "description": f"Analysis error: {e}",
                "correction": "Manual review recommended"
            })

        return suggestions

    def validate_escape_integrity(self, content: str) -> dict:
        """Validar la integridad de los escapes en el contenido"""
        validation = {
            "is_valid": True,
            "issues": [],
            "errors": [],
            "warnings": [],
            "total_escapes": 0
        }
        
        if not content:
            return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions
            
        try:
            # Analizar patrones usando el método existente
            analysis = self.analyze_escape_patterns(content)
            validation["total_escapes"] = analysis.get("total_escapes", 0)
            
            # Detectar problemas comunes
            if "\\\\n" in content:
                validation["issues"].append("Double escaped newlines detected")
                validation["is_valid"] = False
                
            if "\\\\t" in content:
                validation["issues"].append("Double escaped tabs detected")
                validation["is_valid"] = False
                
            if '\\"' in content and content.count('\\"') > content.count('"'):
                validation["warnings"].append("Possible over-escaped quotes")
                
            # Verificar balance de quotes
            single_quotes = content.count("'")
            double_quotes = content.count('"')
            escaped_single = content.count("\\\'")
            escaped_double = content.count('\\"')
            
            if escaped_single > single_quotes:
                validation["warnings"].append("More escaped single quotes than regular ones")
                
            if escaped_double > double_quotes:
                validation["warnings"].append("More escaped double quotes than regular ones")
                
        except Exception as e:
            validation["is_valid"] = False
            validation["issues"].append(f"Validation error: {e}")
            
        return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions


class EscapeProcessor:
    """Procesador avanzado de escape de caracteres"""
    
    def __init__(self):
        """Inicializar EscapeProcessor con patrones avanzados"""
        # Logger
        try:
            from utils.logger import get_logger
            self.logger = get_logger(__name__)
        except ImportError:
            import logging
            self.logger = logging.getLogger(__name__)
        
        # Configuración de corrección
        self.correction_config = {
            "aggressive_mode": False,
            "preserve_intentional": True,
            "backup_enabled": True
        }
        
        # Patrones avanzados compilados
        self.advanced_patterns = {
            "tab_literals": re.compile(r'\\t'),
            "quote_literals": re.compile(r'\\"'),
            "single_quote_literals": re.compile(r"\\\'"),
            "newline_literals": re.compile(r'\\n'),
            "backslash_literals": re.compile(r'\\\\')
        }



    
    def fix_escape_issues(self, content: str, issue_type: str) -> str:
        """Corrige problemas específicos de escape"""
        if not content:
            return content

        # Manejar tipos específicos de problemas
        if issue_type == "double_escape":
            # Corregir escapes dobles como \\\\n -> \n
            content = content.replace("\\\\n", "\n")
            content = content.replace("\\\\t", "\t")
            content = content.replace("\\\\\\\\", "\\")
            
        elif issue_type == "broken_json_escape":
            # Corregir escapes de JSON rotos como \\"quotes\\" -> "quotes"
            content = content.replace('\\"', '"')
            
        elif issue_type == "literal_escapes" or issue_type == "all":
            # Corregir escapes literales usando patrones avanzados
            content = self.advanced_patterns["tab_literals"].sub('\t', content)
            content = self.advanced_patterns["quote_literals"].sub('"', content)
            content = self.advanced_patterns["single_quote_literals"].sub("'", content)
            content = self.advanced_patterns["newline_literals"].sub('\n', content)
            
        # Delegar al SmartContentProcessor si está disponible para casos complejos
        elif SMART_PROCESSOR_AVAILABLE:
            try:
                return SmartContentProcessor.smart_content_processing(
                    content, issue_type
                )
            except Exception as e:
                self.logger.warning(f"SmartContentProcessor failed: {e}")
                # Fallback básico
                return process_content_escapes(content)
        else:
            # Fallback básico para tipos no reconocidos
            return process_content_escapes(content)
            
        return content

    def suggest_escape_corrections(self, content: str) -> list:
        """Sugerir correcciones para problemas de escape"""
        suggestions = []

        if not content:
            return suggestions

        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)

            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_newlines",
                    "description": "Double escaped newlines detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_tabs",
                    "description": "Double escaped tabs detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions.append({
                    "issue": "escaped_quotes",
                    "description": "Escaped quotes detected",
                    "correction": "Use fix_escape_issues with 'broken_json_escape' type"
                })

            # Sugerencias específicas para el test extendido
            if '\\t' in content:
                suggestions.append({
                    "issue": "tab_escapes",
                    "description": "Tab escape literals detected",
                    "correction": "Use fix_escape_issues with 'literal_escapes' type"
                })

        except Exception as e:
            suggestions.append({
                "issue": "analysis_error",
                "description": f"Analysis error: {e}",
                "correction": "Manual review recommended"
            })

        return suggestions

    def validate_escape_integrity(self, content: str) -> dict:
        """Validar la integridad de los escapes en el contenido"""
        validation = {
            "is_valid": True,
            "issues": [],
            "errors": [],
            "warnings": [],
            "total_escapes": 0
        }
        
        if not content:
            return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions
            
        try:
            # Analizar patrones usando el método existente
            analysis = self.analyze_escape_patterns(content)
            validation["total_escapes"] = analysis.get("total_escapes", 0)
            
            # Detectar problemas comunes
            if "\\\\n" in content:
                validation["issues"].append("Double escaped newlines detected")
                validation["is_valid"] = False
                
            if "\\\\t" in content:
                validation["issues"].append("Double escaped tabs detected")
                validation["is_valid"] = False
                
            if '\\"' in content and content.count('\\"') > content.count('"'):
                validation["warnings"].append("Possible over-escaped quotes")
                
            # Verificar balance de quotes
            single_quotes = content.count("'")
            double_quotes = content.count('"')
            escaped_single = content.count("\\\'")
            escaped_double = content.count('\\"')
            
            if escaped_single > single_quotes:
                validation["warnings"].append("More escaped single quotes than regular ones")
                
            if escaped_double > double_quotes:
                validation["warnings"].append("More escaped double quotes than regular ones")
                
        except Exception as e:
            validation["is_valid"] = False
            validation["issues"].append(f"Validation error: {e}")
            
        return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions

        # Manejar tipos específicos de problemas
        if issue_type == "double_escape":
            # Corregir escapes dobles como \\\\n -> \n
            content = content.replace("\\\\n", "\n")
            content = content.replace("\\\\t", "\t")
            content = content.replace("\\\\\\\\", "\\")
            
        elif issue_type == "broken_json_escape":
            # Corregir escapes de JSON rotos como \"quotes\" -> "quotes"
            content = content.replace('\\"', '"')
            
        elif issue_type == "literal_escapes" or issue_type == "all":
            # Corregir escapes literales usando patrones avanzados
            content = self.advanced_patterns["tab_literals"].sub('\t', content)
            content = self.advanced_patterns["quote_literals"].sub('"', content)
            content = self.advanced_patterns["single_quote_literals"].sub("'", content)
            content = self.advanced_patterns["newline_literals"].sub('\n', content)
            
        # Delegar al SmartContentProcessor si está disponible para casos complejos
        elif SMART_PROCESSOR_AVAILABLE:
            try:
                return SmartContentProcessor.smart_content_processing(
                    content, issue_type
                )
            except Exception as e:
                self.logger.warning(f"SmartContentProcessor failed: {e}")
                # Fallback básico
                return process_content_escapes(content)
        else:
            # Fallback básico para tipos no reconocidos
            return process_content_escapes(content)
            
        return content
    
    def fix_escape_issues(self, content: str, issue_type: str) -> str:
        """Corrige problemas específicos de escape"""
        if not content:
            return content

        # Manejar tipos específicos de problemas
        if issue_type == "double_escape":
            # Corregir escapes dobles como \\\\n -> \n
            content = content.replace("\\\\n", "\n")
            content = content.replace("\\\\t", "\t")
            content = content.replace("\\\\\\\\", "\\")
            
        elif issue_type == "broken_json_escape":
            # Corregir escapes de JSON rotos como \\"quotes\\" -> "quotes"
            content = content.replace('\\"', '"')
            
        elif issue_type == "literal_escapes" or issue_type == "all":
            # Corregir escapes literales usando patrones avanzados
            content = self.advanced_patterns["tab_literals"].sub('\t', content)
            content = self.advanced_patterns["quote_literals"].sub('"', content)
            content = self.advanced_patterns["single_quote_literals"].sub("'", content)
            content = self.advanced_patterns["newline_literals"].sub('\n', content)
            
        # Delegar al SmartContentProcessor si está disponible para casos complejos
        elif SMART_PROCESSOR_AVAILABLE:
            try:
                return SmartContentProcessor.smart_content_processing(
                    content, issue_type
                )
            except Exception as e:
                self.logger.warning(f"SmartContentProcessor failed: {e}")
                # Fallback básico
                return process_content_escapes(content)
        else:
            # Fallback básico para tipos no reconocidos
            return process_content_escapes(content)
            
        return content

    def suggest_escape_corrections(self, content: str) -> list:
        """Sugerir correcciones para problemas de escape"""
        suggestions = []

        if not content:
            return suggestions

        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)

            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_newlines",
                    "description": "Double escaped newlines detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions.append({
                    "issue": "double_escape_tabs",
                    "description": "Double escaped tabs detected",
                    "correction": "Use fix_escape_issues with 'double_escape' type"
                })

            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions.append({
                    "issue": "escaped_quotes",
                    "description": "Escaped quotes detected",
                    "correction": "Use fix_escape_issues with 'broken_json_escape' type"
                })

            # Sugerencias específicas para el test extendido
            if '\\t' in content:
                suggestions.append({
                    "issue": "tab_escapes",
                    "description": "Tab escape literals detected",
                    "correction": "Use fix_escape_issues with 'literal_escapes' type"
                })

        except Exception as e:
            suggestions.append({
                "issue": "analysis_error",
                "description": f"Analysis error: {e}",
                "correction": "Manual review recommended"
            })

        return suggestions

    def validate_escape_integrity(self, content: str) -> dict:
        """Validar la integridad de los escapes en el contenido"""
        validation = {
            "is_valid": True,
            "issues": [],
            "errors": [],
            "warnings": [],
            "total_escapes": 0
        }
        
        if not content:
            return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions
            
        try:
            # Analizar patrones usando el método existente
            analysis = self.analyze_escape_patterns(content)
            validation["total_escapes"] = analysis.get("total_escapes", 0)
            
            # Detectar problemas comunes
            if "\\\\n" in content:
                validation["issues"].append("Double escaped newlines detected")
                validation["is_valid"] = False
                
            if "\\\\t" in content:
                validation["issues"].append("Double escaped tabs detected")
                validation["is_valid"] = False
                
            if '\\"' in content and content.count('\\"') > content.count('"'):
                validation["warnings"].append("Possible over-escaped quotes")
                
            # Verificar balance de quotes
            single_quotes = content.count("'")
            double_quotes = content.count('"')
            escaped_single = content.count("\\\'")
            escaped_double = content.count('\\"')
            
            if escaped_single > single_quotes:
                validation["warnings"].append("More escaped single quotes than regular ones")
                
            if escaped_double > double_quotes:
                validation["warnings"].append("More escaped double quotes than regular ones")
                
        except Exception as e:
            validation["is_valid"] = False
            validation["issues"].append(f"Validation error: {e}")
            
        return validation
    
    def DELETED_METHOD_1(self, content: str) -> dict:
        """Sugerir correcciones para problemas de escape"""
        suggestions = {
            "corrections": [],
            "warnings": [],
            "auto_fixable": True
        }
        
        if not content:
            return suggestions
            
        try:
            # Analizar el contenido primero
            analysis = self.analyze_escape_patterns(content)
            validation = self.validate_escape_integrity(content)
            
            # Generar sugerencias basadas en problemas encontrados
            if "Double escaped newlines detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped newlines",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            if "Double escaped tabs detected" in validation.get("issues", []):
                suggestions["corrections"].append({
                    "issue": "Double escaped tabs",
                    "suggestion": "Use fix_escape_issues with 'double_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'double_escape')"
                })
                
            # Sugerencias para escapes de comillas
            if '\\"' in content:
                suggestions["corrections"].append({
                    "issue": "Escaped quotes detected",
                    "suggestion": "Use fix_escape_issues with 'broken_json_escape' type",
                    "auto_fix": "processor.fix_escape_issues(content, 'broken_json_escape')"
                })
                
            # Advertencias generales
            if analysis.get("total_escapes", 0) > 10:
                suggestions["warnings"].append("High number of escape sequences detected")
                
            if not suggestions["corrections"]:
                suggestions["corrections"].append({
                    "issue": "No specific issues detected",
                    "suggestion": "Content appears to be properly escaped",
                    "auto_fix": None
                })
                
        except Exception as e:
            suggestions["auto_fixable"] = False
            suggestions["corrections"].append({
                "issue": f"Analysis error: {e}",
                "suggestion": "Manual review recommended",
                "auto_fix": None
            })
            
        return suggestions

    def analyze_escape_patterns(self, content: str) -> dict:
        """Analiza patrones de escape en contenido"""
        analysis = {"total_escapes": 0, "escape_types": {}, "problematic_sequences": []}

        if not content:
            return analysis

        try:
            # Contar diferentes tipos de escape
            patterns = {
                "newlines": r"\\n",
                "tabs": r"\\t",
                "quotes": r'\\"',
                "single_quotes": r"\\'",
                "backslashes": r"\\\\",
            }

            for name, pattern in patterns.items():
                matches = re.findall(pattern, content)
                if matches:
                    analysis["escape_types"][name] = len(matches)
                    analysis["total_escapes"] += len(matches)

            return analysis
        except Exception as e:
            self.logger.error(f"Error analyzing escape patterns: {e}")
            return analysis
