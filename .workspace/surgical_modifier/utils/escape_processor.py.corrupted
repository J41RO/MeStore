#!/usr/bin/env python3
"""
EscapeProcessor - Procesador especializado para casos complejos de escape.
Incluye función simple process_content_escapes() para corregir bug crítico.
"""

import logging
import re
from utils.smart_content_processor import SmartContentProcessor
from typing import Any, Dict, List, Optional, Tuple

try:
    from utils.logger import get_logger

    logger = get_logger(__name__)
except ImportError:
    import logging

    logger = logging.getLogger(__name__)


def process_content_escapes(content):
    """
    Función simple para corregir el bug crítico de escape de caracteres.
    Convierte \\n literal a salto de línea real según especificación del TODO.

    Args:
        content (str): Content with potential escape sequences

    Returns:
        str: Content with properly processed escape sequences
    """
    if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")

    # Regex específico del TODO: re.sub(r"(?<!\\)\\n", "\n", content)
    content = re.sub(r"(?<!\\)\\n", "\n", content)
    content = re.sub(r"(?<!\\)\\t", "\t", content)
    content = re.sub(r"(?<!\\)\\'", "'", content)
    content = re.sub(r"(?<!\\)\\\"", '"', content)

    return content


class EscapeProcessor:
    """Procesador especializado para casos complejos de escape."""

    def __init__(self):
        """Inicializa el EscapeProcessor."""
        self.logger = logger
        self._setup_advanced_patterns()
        self.logger.info("EscapeProcessor inicializado correctamente")

    def _setup_advanced_patterns(self):
        """Configura patrones avanzados."""
        self.advanced_patterns = {
            "double_escape": re.compile(r"\\\\\\\\([nrtbf])"),
            "malformed_unicode": re.compile(r"\\u([0-9a-fA-F]{1,3})(?![0-9a-fA-F])"),
            "broken_json_escape": re.compile(r'\\"'),
            "incorrect_newlines": re.compile(r"\\n"),
            "tab_literals": re.compile(r"(?<!\\)\\t"),
            "quote_literals": re.compile(r'(?<!\\)\\"'),
            "single_quote_literals": re.compile(r"(?<!\\)\\'"),
        }

        self.correction_config = {
            "preserve_original": True,
            "log_corrections": True,
            "max_iterations": 3,
        }

    def fix_escape_issues(self, content: str, issue_type: str) -> str:
        """Corrige problemas específicos de escape."""
        if not content or not issue_type:
            return content

        original_content = content
        corrections_made = 0

        try:
            if issue_type == "double_escape":
                content = self.advanced_patterns["double_escape"].sub(
                    r"\\\\\\1", content
                )
                corrections_made += 1

            elif issue_type == "malformed_unicode":

                def fix_unicode(match):
                    hex_val = match.group(1)
                    return f"\\\\u{hex_val.zfill(4)}"

                content = self.advanced_patterns["malformed_unicode"].sub(
                    fix_unicode, content
                )
                corrections_made += 1

            elif issue_type == "broken_json_escape":
                content = self.advanced_patterns["broken_json_escape"].sub('"', content)
                corrections_made += 1

            elif issue_type == "incorrect_newlines":
                content = self.advanced_patterns["incorrect_newlines"].sub(
                    "\\n", content
                )
                corrections_made += 1

            elif issue_type == "newline_escapes":
                content = self.fix_newline_escapes(content)
                corrections_made += 1

            elif issue_type == "tab_escapes":
                content = self.fix_tab_escapes(content)
                corrections_made += 1

            elif issue_type == "quote_escapes":
                content = self.fix_quote_escapes(content)
                corrections_made += 1

            elif issue_type == "literal_escapes":
                # Procesar todos los literales: tabs, comillas dobles y simples
                content = self.fix_tab_escapes(content)
                content = self.fix_quote_escapes(content)
                corrections_made += 2

            if self.correction_config["log_corrections"] and corrections_made > 0:
                self.logger.info(
                    f"fix_escape_issues: {corrections_made} correcciones aplicadas para {issue_type}"
                )

            return content

        except Exception as e:
            self.logger.error(f"Error en fix_escape_issues: {e}")
            return (
                original_content
                if self.correction_config["preserve_original"]
                else content
            )

    def fix_newline_escapes(self, content: str) -> str:
        """
        Corrige escapes de newlines específicos usando regex lookbehind.

        Aplica el regex específico: re.sub(r"(?<!\\)\\n", "\n", content)
        Convierte \\n a newline real, pero preserva \\\\n escapado.

        Args:
            content (str): Contenido a procesar

        Returns:
            str: Contenido con newlines corregidos

        Example:
            >>> processor = EscapeProcessor()
            >>> processor.fix_newline_escapes("Normal\\nNewline")
            'Normal\nNewline'
            >>> processor.fix_newline_escapes("Escaped\\\\nNewline")
            'Escaped\\\\nNewline'
        """
        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")

        try:
            self.logger.debug(
                f"Procesando newline escapes en contenido de {len(content)} caracteres"
            )

            # Aplicar regex específico del TODO crítico
            processed_content = re.sub(r"(?<!\\)\\n", "\n", content)

            # Contar correcciones realizadas
            original_count = content.count("\\n")
            processed_count = processed_content.count("\\n")
            corrections = original_count - processed_count

            if corrections > 0:
                self.logger.info(
                    f"fix_newline_escapes: {corrections} newlines corregidos"
                )

            return processed_content

        except Exception as e:
            self.logger.error(f"Error en fix_newline_escapes: {e}")
            return content

    def fix_tab_escapes(self, content: str) -> str:
        """
        Procesa escapes de tabs literales: convierte \\t a \t real.

        Args:
            content (str): Contenido con potenciales escapes de tabs

        Returns:
            str: Contenido con tabs procesados correctamente

        Examples:
            >>> processor = EscapeProcessor()
            >>> processor.fix_tab_escapes('Content\\twith\\ttabs')
            'Content\twith\ttabs'
        """
        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")

        self.logger.debug(f"Processing tab escapes in content: {repr(content[:50])}")

        try:
            # Usar regex exacto de la función auxiliar: convierte \\t a \t real
            result = re.sub(r"(?<!\\)\\t", "\t", content)

            self.logger.debug(f"Tab escape processing completed: {repr(result[:50])}")
            return result

        except Exception as e:
            self.logger.error(f"Error processing tab escapes: {e}")
            return content

    def fix_quote_escapes(self, content: str) -> str:
        """
        Procesa escapes de comillas literales: convierte \\" a " real y \\' a ' real.

        Args:
            content (str): Contenido con potenciales escapes de comillas

        Returns:
            str: Contenido con comillas procesadas correctamente

        Examples:
            >>> processor = EscapeProcessor()
            >>> processor.fix_quote_escapes('Content\\"with\\"quotes')
            'Content"with"quotes'
            >>> processor.fix_quote_escapes("Content\\'with\\'quotes")
            "Content'with'quotes"
        """
        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")

        self.logger.debug(f"Processing quote escapes in content: {repr(content[:50])}")

        try:
            # Usar regex exactos de la función auxiliar
            # Procesar comillas dobles: \\" a " real
            result = re.sub(r'(?<!\\)\\"', '"', content)

            # Procesar comillas simples: \\' a ' real
            result = re.sub(r"(?<!\\)\\'", "'", result)

            self.logger.debug(f"Quote escape processing completed: {repr(result[:50])}")
            return result

        except Exception as e:
            self.logger.error(f"Error processing quote escapes: {e}")
            return content

    def analyze_escape_patterns(self, content: str) -> dict:
        """Analiza patrones de escape en contenido."""
        analysis = {"total_escapes": 0, "escape_types": {}, "problematic_sequences": []}

        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")
            return analysis

        try:
            # Contar diferentes tipos de escape
            for pattern_name, pattern in self.advanced_patterns.items():
                matches = pattern.findall(content)
                if matches:
                    analysis["escape_types"][pattern_name] = len(matches)
                    analysis["total_escapes"] += len(matches)

            # Detectar secuencias problemáticas
            if "\\\\\\\\" in content:
                analysis["problematic_sequences"].append("double_backslash")
            if '\\\\"' in content and '"' in content:
                analysis["problematic_sequences"].append("mixed_quotes")

            return analysis

        except Exception as e:
            self.logger.error(f"Error en analyze_escape_patterns: {e}")
            return analysis

    def validate_escape_integrity(self, content: str) -> dict:
        """Valida integridad de secuencias de escape."""
        validation = {"is_valid": True, "errors": [], "warnings": []}

        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")
            return validation

        try:
            # Validar pares de comillas
            quote_count = content.count('"')
            escaped_quote_count = content.count('\\"')
            if (quote_count - escaped_quote_count) % 2 != 0:
                validation["is_valid"] = False
                validation["errors"].append("unmatched_quotes")

            # Validar secuencias Unicode
            unicode_pattern = re.compile(r"\\u[0-9a-fA-F]{4}")
            malformed_unicode = re.compile(r"\\u[0-9a-fA-F]{1,3}(?![0-9a-fA-F])")

            if malformed_unicode.search(content):
                validation["warnings"].append("malformed_unicode_sequences")

            return validation

        except Exception as e:
            self.logger.error(f"Error en validate_escape_integrity: {e}")
            validation["is_valid"] = False
            validation["errors"].append(f"validation_error: {str(e)}")
            return validation

    def suggest_escape_corrections(self, content: str) -> list:
        """Sugiere correcciones automáticas para problemas de escape."""
        suggestions = []

        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")
            return suggestions

        try:
            analysis = self.analyze_escape_patterns(content)

            # Sugerir correcciones basadas en análisis
            if "double_escape" in analysis["escape_types"]:
                suggestions.append(
                    {
                        "issue": "double_escape",
                        "description": "Escape doble detectado",
                        "correction": 'fix_escape_issues(content, "double_escape")',
                    }
                )

            if "malformed_unicode" in analysis["escape_types"]:
                suggestions.append(
                    {
                        "issue": "malformed_unicode",
                        "description": "Secuencias Unicode malformadas",
                        "correction": 'fix_escape_issues(content, "malformed_unicode")',
                    }
                )

            if "tab_literals" in analysis["escape_types"]:
                suggestions.append(
                    {
                        "issue": "tab_escapes",
                        "description": "Tabs literales detectados",
                        "correction": 'fix_escape_issues(content, "tab_escapes")',
                    }
                )

            if (
                "quote_literals" in analysis["escape_types"]
                or "single_quote_literals" in analysis["escape_types"]
            ):
                suggestions.append(
                    {
                        "issue": "quote_escapes",
                        "description": "Comillas literales detectadas",
                        "correction": 'fix_escape_issues(content, "quote_escapes")',
                    }
                )

            if "double_backslash" in analysis["problematic_sequences"]:
                suggestions.append(
                    {
                        "issue": "normalize_needed",
                        "description": "Normalización de secuencias requerida",
                        "correction": "normalize_escape_sequences(content)",
                    }
                )

            return suggestions

        except Exception as e:
            self.logger.error(f"Error en suggest_escape_corrections: {e}")
            return suggestions

    def normalize_escape_sequences(self, content: str) -> str:
        """Normaliza secuencias inconsistentes de escape."""
        if not content:
        return content
    # Use SmartContentProcessor for better escape handling
    return SmartContentProcessor.smart_content_processing(content, "general")

        try:
            normalized = content

            # Normalizar backslashes múltiples
            normalized = re.sub(r"\\{3,}", "\\\\", normalized)

            # Normalizar comillas escape
            normalized = re.sub(r'\\{2,}"', '\\"', normalized)

            # Normalizar secuencias de control
            control_chars = {"n": "\n", "t": "\t", "r": "\r", "b": "\b", "f": "\f"}
            for char, replacement in control_chars.items():
                pattern = f"\\\\{char}"
                normalized = normalized.replace(pattern, replacement)

            if self.correction_config["log_corrections"]:
                if normalized != content:
                    self.logger.info(
                        "normalize_escape_sequences: Secuencias normalizadas"
                    )

            return normalized

        except Exception as e:
            self.logger.error(f"Error en normalize_escape_sequences: {e}")
            return content if self.correction_config["preserve_original"] else content

    def integrate_with_content_handler(self) -> dict:
        """Integra con ExtremeContentHandler para casos complejos."""
        integration_info = {
            "compatible": False,
            "handler_available": False,
            "integration_methods": [],
        }

        try:
            from utils.content_handler import ExtremeContentHandler

            integration_info["handler_available"] = True
            integration_info["compatible"] = True

            # Métodos de integración disponibles
            integration_info["integration_methods"] = [
                "enhanced_escape_processing",
                "fallback_to_extreme_handler",
                "combined_pattern_detection",
            ]

            self.logger.info("Integración con ExtremeContentHandler exitosa")
            return integration_info

        except ImportError as e:
            self.logger.warning(f"ExtremeContentHandler no disponible: {e}")
            integration_info["handler_available"] = False
            return integration_info
        except Exception as e:
            self.logger.error(f"Error en integración: {e}")
            return integration_info
    
    def process_raw_content(self, content: str, mode: str = 'preserve') -> str:
        """
        Procesa contenido con múltiples niveles de escape en modo raw avanzado.
        
        Args:
            content: Contenido con escapes complejos
            mode: 'preserve' mantiene escapes, 'convert' los procesa, 'auto' decide
            
        Returns:
            Contenido procesado según el modo especificado
        """
        try:
            self.logger.debug(f"Processing raw content in mode: {mode}")
            
            if mode == 'preserve':
                # Mantener todos los escapes intactos
                return self._preserve_raw_escapes(content)
            elif mode == 'convert':
                # Procesar todos los escapes
                return self._convert_raw_escapes(content)
            elif mode == 'auto':
                # Decidir automáticamente basado en el contenido
                return self._auto_process_raw_content(content)
            else:
                self.logger.warning(f"Unknown mode: {mode}, using preserve")
                return self._preserve_raw_escapes(content)
                
        except Exception as e:
            self.logger.error(f"Error processing raw content: {e}")
            return content
    
    def _preserve_raw_escapes(self, content: str) -> str:
        """
        Preserva todos los escapes en el contenido original.
        
        Args:
            content: Contenido original
            
        Returns:
            Contenido con escapes preservados
        """
        # Convertir escapes dobles a preservados
        preserved = content.replace('\\\\', '\x00DOUBLE_BACKSLASH\x00')
        preserved = preserved.replace('\\"', '\x00ESCAPED_QUOTE\x00')
        preserved = preserved.replace('\\n', '\x00ESCAPED_NEWLINE\x00')
        preserved = preserved.replace('\\t', '\x00ESCAPED_TAB\x00')
        
        # Restaurar con escapes preservados
        preserved = preserved.replace('\x00DOUBLE_BACKSLASH\x00', '\\\\')
        preserved = preserved.replace('\x00ESCAPED_QUOTE\x00', '\\"')
        preserved = preserved.replace('\x00ESCAPED_NEWLINE\x00', '\\n')
        preserved = preserved.replace('\x00ESCAPED_TAB\x00', '\\t')
        
        return preserved
    
    def _convert_raw_escapes(self, content: str) -> str:
        """
        Convierte escapes anidados a su forma final.
        
        Args:
            content: Contenido con escapes anidados
            
        Returns:
            Contenido con escapes convertidos
        """
        # Procesar escapes anidados paso a paso
        converted = content
        
        # Convertir \\\\ → \\
        converted = re.sub(r'\\\\\\\\', '\\\\', converted)
        
        # Convertir \\n → \n
        converted = re.sub(r'\\\\n', '\\n', converted)
        
        # Convertir \\t → \t  
        converted = re.sub(r'\\\\t', '\\t', converted)
        
        # Convertir \\" → \"
        converted = re.sub(r'\\\\"', '\\"', converted)
        
        return converted
    
    def _auto_process_raw_content(self, content: str) -> str:
        """
        Decide automáticamente cómo procesar el contenido basado en patrones.
        
        Args:
            content: Contenido a analizar
            
        Returns:
            Contenido procesado automáticamente
        """
        # Contar niveles de escape
        double_backslashes = content.count('\\\\')
        single_backslashes = content.count('\\') - (double_backslashes * 2)
        
        # Si hay muchos escapes dobles, probablemente necesita conversión
        if double_backslashes > single_backslashes:
            self.logger.debug("Auto-mode: Converting escapes")
            return self._convert_raw_escapes(content)
        else:
            self.logger.debug("Auto-mode: Preserving escapes")
            return self._preserve_raw_escapes(content)
