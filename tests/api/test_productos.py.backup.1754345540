# ~/tests/api/test_productos.py
# ---------------------------------------------------------------------------------------------
# MESTORE - Tests para endpoints de productos
# Copyright (c) 2025 Jairo. Todos los derechos reservados.
# Licensed under the proprietary license detailed in a LICENSE file in the root of this project.
# ---------------------------------------------------------------------------------------------
#
# Nombre del Archivo: test_productos.py
# Ruta: ~/tests/api/test_productos.py
# Autor: Jairo
# Fecha de Creación: 2025-01-14
# Última Actualización: 2025-01-14
# Versión: 1.0.0
# Propósito: Tests para endpoints de productos de la API v1
#            Validar funcionalidad del endpoint POST /productos
#
# Modificaciones:
# 2025-01-14 - Implementación inicial de tests básicos
#
# ---------------------------------------------------------------------------------------------

"""
Tests para endpoints de productos.

Este módulo contiene:
- Tests para endpoint POST /productos
- Validación de creación exitosa
- Validación de errores (SKU duplicado)
- Tests de validación de datos
"""

import time

import pytest
from httpx import AsyncClient
from fastapi.testclient import TestClient

from app.main import app
from app.models.product import Product


class TestCreateProducto:
    """Test suite para endpoint POST /productos"""

    def test_create_producto_success(self, client_with_test_db: TestClient):
        """Test creación exitosa de producto."""
        # SKU único para evitar duplicados
        timestamp = int(time.time() * 1000)  # timestamp en milisegundos
        product_data = {
            "sku": f"TEST-{timestamp}",  # SKU único basado en timestamp
            "name": "Producto Test",
            "description": "Descripción del producto test",
            "precio_venta": 150.0,
            "categoria": "Electrónicos",
        }

        response = client_with_test_db.post("/api/v1/productos/", json=product_data)

        assert response.status_code == 201
        data = response.json()
        assert data["sku"] == f"TEST-{timestamp}"
        assert data["name"] == "Producto Test"
        assert data["precio_venta"] == 150.0
        assert "id" in data
        assert data["categoria"] == "Electrónicos"

    def test_create_producto_duplicate_sku(self, client_with_test_db: TestClient):
        """Test error por SKU duplicado."""
        # Usar timestamp único también aquí
        timestamp = int(time.time() * 1000)
        product_data = {
            "sku": f"DUP-{timestamp}",
            "name": "Producto Duplicado",
            "description": "Test duplicado",
            "precio_venta": 150.0,
            "categoria": "Test",
        }

        # Crear primer producto
        response1 = client_with_test_db.post("/api/v1/productos/", json=product_data)
        assert response1.status_code == 201

        # Intentar crear duplicado (mismo SKU)
        response2 = client_with_test_db.post("/api/v1/productos/", json=product_data)
        assert response2.status_code == 400
        assert "ya existe" in response2.json()["detail"]

    def test_create_producto_invalid_data(self, client_with_test_db: TestClient):
        """Test validación de datos inválidos."""
        # Test sin SKU requerido
        invalid_data = {
            "name": "Producto Sin SKU",
            "description": "Test sin SKU",
            "precio_venta": 150.0,
            "categoria": "Test",
        }

        response = client_with_test_db.post("/api/v1/productos/", json=invalid_data)
        assert response.status_code == 422  # Validation error

    def test_create_producto_minimal_data(self, client_with_test_db: TestClient):
        """Test creación con datos mínimos requeridos."""
        # SKU único para este test también
        timestamp = int(time.time() * 1000)
        minimal_data = {
            "sku": f"MIN-{timestamp}",
            "name": "Producto Mínimo",
            "description": "Test mínimo",
            "precio_venta": 100.0,  # Precio mínimo válido
            "categoria": "Test",
        }

        response = client_with_test_db.post("/api/v1/productos/", json=minimal_data)

        assert response.status_code == 201
        data = response.json()
        assert data["sku"] == f"MIN-{timestamp}"
        assert data["name"] == "Producto Mínimo"

class TestGetProductos:
    """Tests para endpoint GET /productos con filtros y paginación."""

    @pytest.mark.asyncio
    async def test_get_productos_empty_list(self, async_client: AsyncClient):
        """Test GET productos cuando no hay productos en la base de datos."""
        response = await async_client.get("/api/v1/productos/")
        
        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, list)
        assert len(data) >= 0  # Puede haber productos de tests anteriores

    @pytest.mark.asyncio
    async def test_get_productos_basic_list(self, async_client: AsyncClient):
        """Test GET productos lista básica sin filtros."""
        # Test funciona con productos existentes en la base de datos
        response = await async_client.get("/api/v1/productos/")
        
        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, list)
        assert len(data) > 0
        
        # Verificar estructura de respuesta
        producto = data[0]
        assert "id" in producto
        assert "sku" in producto
        assert "name" in producto
        assert "precio_venta" in producto

    @pytest.mark.asyncio
    async def test_get_productos_search_filter(self, async_client: AsyncClient, sample_products):
        """Test filtro de búsqueda por texto."""
        # Crear producto específico para búsqueda
        import time
        timestamp = int(time.time() * 1000)
        search_product = {
            "sku": f"SEARCH-{timestamp}",
            "name": "Producto Especial Búsqueda",
            "description": "Test de búsqueda específica",
            "precio_venta": 150.0,
            "categoria": "Test"
        }
        
        create_response = await async_client.post("/api/v1/productos/", json=search_product)
        assert create_response.status_code == 201
        
        # Buscar por nombre
        response = await async_client.get("/api/v1/productos/?search=Especial")
        assert response.status_code == 200
        data = response.json()
        assert len(data) >= 1
        assert any("Especial" in p["name"] for p in data)

    @pytest.mark.asyncio
    async def test_get_productos_categoria_filter(self, async_client: AsyncClient):
        """Test filtro por categoría."""
        import time
        timestamp = int(time.time() * 1000)
        
        # Crear producto con categoría específica
        category_product = {
            "sku": f"CAT-{timestamp}",
            "name": "Producto Categoría Test",
            "description": "Test filtro categoría",
            "precio_venta": 200.0,
            "categoria": "Electrónicos"
        }
        
        create_response = await async_client.post("/api/v1/productos/", json=category_product)
        assert create_response.status_code == 201
        
        # Filtrar por categoría
        response = await async_client.get("/api/v1/productos/?categoria=Electrónicos")
        assert response.status_code == 200
        data = response.json()
        assert len(data) >= 1
        assert all("Electrónicos" in p["categoria"] for p in data)

    @pytest.mark.asyncio
    async def test_get_productos_price_range_filter(self, async_client: AsyncClient):
        """Test filtros de rango de precio."""
        import time
        timestamp = int(time.time() * 1000)
        
        # Crear producto con precio específico
        price_product = {
            "sku": f"PRICE-{timestamp}",
            "name": "Producto Precio Test",
            "description": "Test filtro precio",
            "precio_venta": 299.99,
            "categoria": "Test"
        }
        
        create_response = await async_client.post("/api/v1/productos/", json=price_product)
        assert create_response.status_code == 201
        
        # Filtrar por rango de precio
        response = await async_client.get("/api/v1/productos/?precio_min=250&precio_max=350")
        assert response.status_code == 200
        data = response.json()
        assert len(data) >= 1
        assert all(250 <= p["precio_venta"] <= 350 for p in data)

    @pytest.mark.asyncio
    async def test_get_productos_pagination(self, async_client: AsyncClient):
        """Test paginación."""
        # Test con límite específico
        response = await async_client.get("/api/v1/productos/?limit=2")
        assert response.status_code == 200
        data = response.json()
        assert len(data) <= 2
        
        # Test con skip
        response = await async_client.get("/api/v1/productos/?skip=1&limit=1")
        assert response.status_code == 200
        data = response.json()
        assert len(data) <= 1

    @pytest.mark.asyncio
    async def test_get_productos_sorting(self, async_client: AsyncClient):
        """Test ordenamiento."""
        # Test ordenamiento por precio ascendente
        response = await async_client.get("/api/v1/productos/?sort_by=precio_venta&sort_order=asc")
        assert response.status_code == 200
        data = response.json()
        
        if len(data) > 1:
            # Verificar que están ordenados por precio ascendente
            precios = [p["precio_venta"] for p in data]
            assert precios == sorted(precios)