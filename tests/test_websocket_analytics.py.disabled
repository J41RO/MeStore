# tests/test_websocket_analytics.py
# TDD TESTS: Backend WebSocket Analytics Endpoint
# Target: <150ms response time with JWT authentication

import pytest
import asyncio
import json
from datetime import datetime, timedelta
from fastapi.testclient import TestClient
from fastapi.websockets import WebSocketDisconnect
from unittest.mock import AsyncMock, patch
from sqlalchemy.ext.asyncio import AsyncSession

from app.main import app
from app.models.user import User, UserType
from app.models.product import Product
from app.models.order import Order
from app.models.commission import Commission
from app.core.auth import create_access_token
from app.database import get_db

# Mark all tests as TDD
pytestmark = pytest.mark.tdd

@pytest.fixture
def test_client():
    """Create test client for WebSocket testing"""
    return TestClient(app)

@pytest.fixture
async def vendor_user(db_session: AsyncSession):
    """Create a vendor user for testing"""
    user = User(
        email="vendor@test.com",
        hashed_password="test_password",
        user_type=UserType.VENDOR,
        is_active=True,
        is_verified=True
    )
    db_session.add(user)
    await db_session.commit()
    await db_session.refresh(user)
    return user

@pytest.fixture
def vendor_jwt_token(vendor_user: User):
    """Create JWT token for vendor user"""
    token_data = {
        "sub": vendor_user.email,
        "user_id": str(vendor_user.id),
        "user_type": vendor_user.user_type.value
    }
    return create_access_token(data=token_data)

@pytest.fixture
async def vendor_with_data(db_session: AsyncSession, vendor_user: User):
    """Create vendor with sample products, orders, and commissions"""
    # Create products
    products = []
    for i in range(5):
        product = Product(
            name=f"Test Product {i}",
            description=f"Description {i}",
            price=100.0 + i * 10,
            vendor_id=str(vendor_user.id),
            stock_quantity=50 - i * 5,
            is_active=True
        )
        products.append(product)
        db_session.add(product)

    await db_session.commit()

    # Create orders
    orders = []
    for i, product in enumerate(products):
        order = Order(
            product_id=str(product.id),
            vendor_id=str(vendor_user.id),
            quantity=2 + i,
            total_amount=product.price * (2 + i),
            status="COMPLETED",
            created_at=datetime.utcnow() - timedelta(days=i)
        )
        orders.append(order)
        db_session.add(order)

    await db_session.commit()

    # Create commissions
    for order in orders:
        commission = Commission(
            vendor_id=str(vendor_user.id),
            order_id=str(order.id),
            commission_amount=order.total_amount * 0.1,
            status="APPROVED",
            created_at=order.created_at
        )
        db_session.add(commission)

    await db_session.commit()

    return vendor_user, products, orders

class TestWebSocketAnalyticsRED:
    """RED Phase: Tests that should fail initially"""

    @pytest.mark.red_test
    def test_websocket_without_token_should_fail(self, test_client):
        """RED: WebSocket connection should fail without JWT token"""
        with pytest.raises(Exception):
            with test_client.websocket_connect("/api/v1/analytics/ws/vendor/analytics"):
                pass

    @pytest.mark.red_test
    def test_websocket_with_invalid_token_should_fail(self, test_client):
        """RED: WebSocket connection should fail with invalid JWT token"""
        with pytest.raises(Exception):
            with test_client.websocket_connect(
                "/api/v1/analytics/ws/vendor/analytics?token=invalid_token"
            ):
                pass

    @pytest.mark.red_test
    def test_websocket_non_vendor_user_should_fail(self, test_client, db_session: AsyncSession):
        """RED: WebSocket should reject non-vendor users"""
        # Create buyer user
        buyer = User(
            email="buyer@test.com",
            hashed_password="test_password",
            user_type=UserType.BUYER,
            is_active=True,
            is_verified=True
        )
        db_session.add(buyer)
        await db_session.commit()

        # Create token for buyer
        token_data = {
            "sub": buyer.email,
            "user_id": str(buyer.id),
            "user_type": buyer.user_type.value
        }
        buyer_token = create_access_token(data=token_data)

        with pytest.raises(Exception):
            with test_client.websocket_connect(
                f"/api/v1/analytics/ws/vendor/analytics?token={buyer_token}"
            ):
                pass

class TestWebSocketAnalyticsGREEN:
    """GREEN Phase: Basic functionality implementation"""

    @pytest.mark.green_test
    def test_websocket_connection_with_valid_token(self, test_client, vendor_jwt_token):
        """GREEN: WebSocket should connect with valid vendor token"""
        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}"
        ) as websocket:
            # Should receive connection confirmation
            data = websocket.receive_json()
            assert data["type"] == "connection_status"
            assert data["data"]["status"] == "connected"
            assert "connection_time" in data["data"]

    @pytest.mark.green_test
    def test_websocket_sends_initial_analytics_data(
        self, test_client, vendor_jwt_token, vendor_with_data
    ):
        """GREEN: WebSocket should send initial analytics data after connection"""
        vendor_user, products, orders = vendor_with_data

        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}&vendor_id={vendor_user.id}"
        ) as websocket:
            # Receive connection confirmation
            websocket.receive_json()

            # Should receive initial analytics data
            analytics_data = websocket.receive_json()
            assert analytics_data["type"] == "analytics_update"
            assert "data" in analytics_data

            data = analytics_data["data"]
            assert "metrics" in data
            assert "topProducts" in data
            assert "salesByCategory" in data
            assert "monthlyTrends" in data

            # Verify metrics structure
            metrics = data["metrics"]
            assert "revenue" in metrics
            assert "orders" in metrics
            assert "products" in metrics
            assert "customers" in metrics

    @pytest.mark.green_test
    def test_websocket_ping_pong_mechanism(self, test_client, vendor_jwt_token):
        """GREEN: WebSocket should respond to ping with pong"""
        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}"
        ) as websocket:
            # Skip connection messages
            websocket.receive_json()  # connection_status
            websocket.receive_json()  # analytics_update

            # Send ping
            ping_message = {
                "type": "ping",
                "timestamp": datetime.utcnow().isoformat()
            }
            websocket.send_json(ping_message)

            # Should receive pong
            response = websocket.receive_json()
            assert response["type"] == "connection_status"
            assert response["data"]["type"] == "pong"

    @pytest.mark.green_test
    def test_websocket_refresh_analytics_command(
        self, test_client, vendor_jwt_token, vendor_with_data
    ):
        """GREEN: WebSocket should handle refresh analytics command"""
        vendor_user, products, orders = vendor_with_data

        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}&vendor_id={vendor_user.id}"
        ) as websocket:
            # Skip initial messages
            websocket.receive_json()  # connection_status
            websocket.receive_json()  # initial analytics_update

            # Send refresh command
            refresh_message = {
                "type": "refresh_analytics",
                "timestamp": datetime.utcnow().isoformat()
            }
            websocket.send_json(refresh_message)

            # Should receive updated analytics data
            response = websocket.receive_json()
            assert response["type"] == "analytics_update"
            assert "data" in response

class TestWebSocketAnalyticsREFACTOR:
    """REFACTOR Phase: Performance and reliability improvements"""

    @pytest.mark.refactor_test
    def test_websocket_response_time_under_150ms(
        self, test_client, vendor_jwt_token, vendor_with_data
    ):
        """REFACTOR: WebSocket responses should be under 150ms"""
        vendor_user, products, orders = vendor_with_data

        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}&vendor_id={vendor_user.id}"
        ) as websocket:
            # Skip initial messages
            websocket.receive_json()  # connection_status
            websocket.receive_json()  # initial analytics_update

            # Measure response time for ping
            start_time = datetime.utcnow()

            ping_message = {
                "type": "ping",
                "timestamp": start_time.isoformat()
            }
            websocket.send_json(ping_message)

            response = websocket.receive_json()
            end_time = datetime.utcnow()

            response_time = (end_time - start_time).total_seconds() * 1000
            assert response_time < 150  # Target: <150ms

    @pytest.mark.refactor_test
    def test_websocket_handles_invalid_json_gracefully(
        self, test_client, vendor_jwt_token
    ):
        """REFACTOR: WebSocket should handle invalid JSON without crashing"""
        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}"
        ) as websocket:
            # Skip initial messages
            websocket.receive_json()  # connection_status
            websocket.receive_json()  # analytics_update

            # Send invalid JSON (this would be handled by the client normally)
            # In a real scenario, we'd test malformed message handling
            valid_message = {
                "type": "ping",
                "timestamp": datetime.utcnow().isoformat()
            }
            websocket.send_json(valid_message)

            # Should still respond normally
            response = websocket.receive_json()
            assert response["type"] == "connection_status"

    @pytest.mark.refactor_test
    async def test_websocket_connection_manager_multiple_connections(
        self, test_client, vendor_jwt_token
    ):
        """REFACTOR: Connection manager should handle multiple connections"""
        connections = []

        try:
            # Create multiple connections
            for i in range(3):
                websocket = test_client.websocket_connect(
                    f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}"
                ).__enter__()
                connections.append(websocket)

                # Verify each connection works
                data = websocket.receive_json()
                assert data["type"] == "connection_status"

            # Test that all connections are managed
            # This would require access to the connection manager state
            # In practice, we'd test via status endpoint

        finally:
            # Clean up connections
            for websocket in connections:
                try:
                    websocket.__exit__(None, None, None)
                except:
                    pass

    @pytest.mark.refactor_test
    def test_websocket_analytics_data_accuracy(
        self, test_client, vendor_jwt_token, vendor_with_data
    ):
        """REFACTOR: Analytics data should be accurate and consistent"""
        vendor_user, products, orders = vendor_with_data

        with test_client.websocket_connect(
            f"/api/v1/analytics/ws/vendor/analytics?token={vendor_jwt_token}&vendor_id={vendor_user.id}"
        ) as websocket:
            # Skip connection confirmation
            websocket.receive_json()

            # Get analytics data
            analytics_response = websocket.receive_json()
            data = analytics_response["data"]

            # Verify data accuracy
            metrics = data["metrics"]

            # Check that orders count matches created orders
            assert metrics["orders"]["current"] >= len(orders)

            # Check that products count matches created products
            assert metrics["products"]["total"] == len(products)
            assert metrics["products"]["active"] == len([p for p in products if p.is_active])

            # Check revenue is positive and reasonable
            assert metrics["revenue"]["current"] > 0

            # Check trends are properly calculated
            assert metrics["revenue"]["trend"] in ["up", "down", "stable"]
            assert metrics["orders"]["trend"] in ["up", "down", "stable"]

class TestWebSocketConnectionManager:
    """Test the WebSocket connection manager functionality"""

    @pytest.mark.green_test
    def test_connection_status_endpoint(self, test_client):
        """GREEN: Connection status endpoint should return current state"""
        response = test_client.get("/api/v1/analytics/websocket/status")
        assert response.status_code == 200

        data = response.json()
        assert "total_connections" in data
        assert "active_vendors" in data
        assert "vendor_connections" in data
        assert isinstance(data["total_connections"], int)
        assert isinstance(data["active_vendors"], int)

    @pytest.mark.green_test
    def test_test_broadcast_endpoint(self, test_client):
        """GREEN: Test broadcast endpoint should work"""
        test_message = {"test": "message", "value": 123}

        response = test_client.post(
            "/api/v1/analytics/websocket/test-broadcast",
            json=test_message
        )
        assert response.status_code == 200

        data = response.json()
        assert data["status"] == "sent_to_all"
        assert "connections" in data

@pytest.mark.asyncio
async def test_get_vendor_analytics_data_function(db_session: AsyncSession):
    """Test the analytics data retrieval function directly"""
    from app.api.v1.endpoints.websocket_analytics import get_vendor_analytics_data

    # Create test vendor
    vendor = User(
        email="analytics@test.com",
        hashed_password="test_password",
        user_type=UserType.VENDOR,
        is_active=True
    )
    db_session.add(vendor)
    await db_session.commit()
    await db_session.refresh(vendor)

    # Get analytics data
    analytics_data = await get_vendor_analytics_data(str(vendor.id), db_session)

    # Verify structure
    assert "metrics" in analytics_data
    assert "topProducts" in analytics_data
    assert "salesByCategory" in analytics_data
    assert "monthlyTrends" in analytics_data

    # With no data, should return empty/zero values
    assert analytics_data["metrics"]["revenue"]["current"] == 0
    assert analytics_data["metrics"]["orders"]["current"] == 0
    assert len(analytics_data["topProducts"]) == 0
    assert len(analytics_data["monthlyTrends"]) == 6  # 6 months of trends