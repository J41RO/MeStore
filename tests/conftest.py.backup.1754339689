"""
Configuración global de fixtures para testing del backend.
Archivo: backend/tests/conftest.py
Autor: Sistema de desarrollo
Fecha: 2025-07-18
Propósito: Fixtures centralizados para FastAPI testing con soporte async
"""

import asyncio
import os
# Configurar variables de entorno para testing ANTES de importar app
os.environ['TESTING'] = 'true'
os.environ['CORS_ORIGINS'] = 'http://localhost:3000,http://localhost:8000,https://mestocker.com'
from typing import AsyncGenerator, Generator
from httpx import AsyncClient, ASGITransport

import pytest
from unittest.mock import AsyncMock
from fastapi.testclient import TestClient

from app.main import app


@pytest.fixture(scope="session")
def event_loop() -> Generator[asyncio.AbstractEventLoop, None, None]:
    """
    Fixture para event loop de asyncio compatible con pytest-asyncio.

    Scope: session - Un loop por sesión de testing completa.
    Yield: Event loop de asyncio para tests async.

    Nota: Con asyncio_mode = auto, pytest-asyncio maneja el loop automáticamente.
    Este fixture está disponible para casos específicos que lo requieran.
    """
    try:
        # Intentar obtener loop actual si existe
        loop = asyncio.get_running_loop()
    except RuntimeError:
        # Si no hay loop corriendo, crear uno nuevo
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

    yield loop

    # Solo cerrar si creamos el loop nosotros
    if not loop.is_running():
        loop.close()


@pytest.fixture(scope="module")
def client() -> TestClient:
    """
    Fixture para TestClient de FastAPI.

    Scope: module - Un cliente por módulo de tests.
    Returns: TestClient configurado con la app FastAPI principal.
    """
    return TestClient(app)

@pytest.fixture(scope="function")
async def async_client() -> AsyncGenerator[AsyncClient, None]:
    """
    Fixture async para AsyncClient cuando se requieren operaciones async.
    
    Scope: function - Nuevo cliente por test function.
    Yields: AsyncClient para operaciones async.
    """
    # Headers con User-Agent válido para evitar bloqueo de middleware
    headers = {
        'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
    }
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://testserver", headers=headers) as ac:
        yield ac

@pytest.fixture(scope="session")
def test_config():
    """
    Fixture para configuración específica de testing.

    Returns: Dict con configuración de test environment.
    """
    return {
        "testing": True,
        "database_url": "sqlite:///./test.db",
        "log_level": "DEBUG",
        "disable_auth": True,  # Para tests que no requieren autenticación
        "async_mode": "auto",  # Compatible con pytest-asyncio
    }


@pytest.fixture(autouse=True)
def cleanup_test_data():
    """
    Fixture auto-ejecutado para limpiar datos entre tests.

    Autouse: True - Se ejecuta automáticamente en cada test.
    Yields: Permite ejecución del test, luego limpia.
    """
    # Setup antes del test
    yield
    # Cleanup después del test
    # Aquí irá limpieza de base de datos, cache, etc.
    pass


@pytest.fixture(scope="function")
def mock_database():
    """
    Fixture para base de datos mock/temporal.

    Returns: Configuración de base de datos temporal para tests.
    """
    return {
        "url": "sqlite:///:memory:",
        "echo": False,
        "pool_pre_ping": True,
    }


# === FIXTURES DE BASE DE DATOS DE TESTING ===

import tempfile
from typing import Generator
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from sqlalchemy.ext.asyncio import AsyncSession, create_async_engine, async_sessionmaker
from sqlalchemy.pool import StaticPool
from app.core.database import Base, get_db
from app.main import app


# Configuración de base de datos de testing
SQLALCHEMY_TEST_DATABASE_URL = "sqlite:///:memory:"

# Engine de testing con configuración específica para SQLite en memoria
test_engine = create_engine(
    SQLALCHEMY_TEST_DATABASE_URL,
    connect_args={"check_same_thread": False},  # Permitir múltiples threads para testing
    poolclass=StaticPool,  # Pool estático para SQLite en memoria
    echo=False  # Cambiar a True para debug SQL
)

# SessionLocal para testing
TestingSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=test_engine)


# Engine async para testing
async_test_engine = create_async_engine(
    "sqlite+aiosqlite:///:memory:",
    echo=False,
    pool_pre_ping=True
)

# SessionLocal async para testing
AsyncTestingSessionLocal = async_sessionmaker(
    bind=async_test_engine,
    class_=AsyncSession,
    expire_on_commit=False
)


@pytest.fixture(scope="function")
def test_db_session() -> Generator[Session, None, None]:
    """
    Fixture para sesión de base de datos de testing.
    
    Scope: function - Nueva DB limpia por cada test.
    Creates: Todas las tablas en SQLite en memoria.
    Yields: Sesión de SQLAlchemy para el test.
    Cleanup: Cierra sesión y destruye tablas.
    """
    # Crear todas las tablas en la base de datos de testing
    Base.metadata.create_all(bind=test_engine)
    
    # Crear sesión para el test
    db_session = TestingSessionLocal()
    
    try:
        yield db_session
    finally:
        db_session.close()
        # Limpiar todas las tablas después del test
        Base.metadata.drop_all(bind=test_engine)



@pytest.fixture(scope="function")
async def async_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Fixture para sesión async de base de datos de testing.

    Scope: function - Nueva DB async limpia por cada test.
    Yields: AsyncSession de SQLAlchemy para tests async.
    """
    # Crear todas las tablas
    async with async_test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

    # Crear sesión async para el test
    async with AsyncTestingSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()

    # Limpiar tablas después del test
    async with async_test_engine.begin() as conn:
        await conn.run_sync(Base.metadata.drop_all)


@pytest.fixture(scope="function")
def override_get_db(test_db_session: Session) -> Generator[None, None, None]:
    """
    Fixture para override de dependencia get_db de FastAPI.
    
    Scope: function - Override por test individual.
    Effect: Redirige get_db() a la sesión de testing.
    Cleanup: Restaura dependencia original.
    """
    def get_test_db() -> Generator[Session, None, None]:
        """Dependencia de testing que retorna la sesión de test."""
        try:
            yield test_db_session
        finally:
            pass  # Session cleanup manejado por test_db_session fixture
    
    # Override de la dependencia get_db
    app.dependency_overrides[get_db] = get_test_db
    
    yield
    
    # Limpiar override después del test
    app.dependency_overrides.clear()


@pytest.fixture(scope="function")  
def client_with_test_db(override_get_db) -> TestClient:
    """
    Fixture para TestClient con base de datos de testing configurada.
    
    Scope: function - Cliente limpio por test.
    Requires: override_get_db fixture activo.
    Returns: TestClient que usa base de datos de testing.
    """
    return TestClient(app)


@pytest.fixture(scope="function")
def test_db_url() -> str:
    """
    Fixture que retorna la URL de la base de datos de testing.
    
    Returns: URL de SQLite en memoria para logging/debugging.
    """
    return SQLALCHEMY_TEST_DATABASE_URL


@pytest.fixture(autouse=True)
async def mock_redis_for_testing(monkeypatch):
    """Mock Redis para tests sin autenticación"""
    mock_redis = AsyncMock()
    mock_redis.ping.return_value = True
    mock_redis.get.return_value = None
    mock_redis.set.return_value = True
    mock_redis.delete.return_value = 1

    async def mock_get_redis():
        return mock_redis

    monkeypatch.setattr("app.core.redis.redis_manager.get_redis", mock_get_redis)
    return mock_redis