// ~/src/components/ui/ImageUpload/__tests__/ImageUpload.test.tsx
// ---------------------------------------------------------------------------------------------
// MESTORE - ImageUpload Component Tests
// Copyright (c) 2025 Jairo. Todos los derechos reservados.
// Licensed under the proprietary license detailed in a LICENSE file in the root of this project.
// ---------------------------------------------------------------------------------------------
//
// Nombre del Archivo: ImageUpload.test.tsx
// Ruta: ~/src/components/ui/ImageUpload/__tests__/ImageUpload.test.tsx
// Autor: Jairo
// Fecha de Creaci칩n: 2025-08-18
// 칔ltima Actualizaci칩n: 2025-08-18
// Versi칩n: 1.0.0
// Prop칩sito: Tests unitarios para el componente ImageUpload
//            Cobertura de funcionalidad drag & drop, validaciones y preview
//
// Modificaciones:
// 2025-08-18 - Creaci칩n inicial con tests completos
//
// ---------------------------------------------------------------------------------------------

import React from 'react';
import { render, screen, fireEvent, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { describe, it, expect, beforeEach } from 'vitest';
import { vi } from 'vitest';
import ImageUpload from '../ImageUpload';
import { ImageUploadProps } from '../ImageUpload.types';

// Mock de react-dropzone
vi.mock('react-dropzone', () => ({
  useDropzone: vi.fn(() => ({
    getRootProps: () => ({ 'data-testid': 'dropzone' }),
    getInputProps: () => ({ 'data-testid': 'file-input' }),
    isDragActive: false,
    isDragAccept: false,
    isDragReject: false,
    fileRejections: [],
  })),
}));

// Mock de URL.createObjectURL
global.URL.createObjectURL = vi.fn(() => 'mock-preview-url');
global.URL.revokeObjectURL = vi.fn();

describe('ImageUpload Component', () => {
  const mockOnImageUpload = vi.fn();
  
  const defaultProps: ImageUploadProps = {
    onImageUpload: mockOnImageUpload,
    maxFiles: 5,
    maxSize: 5 * 1024 * 1024,
    acceptedTypes: ['image/jpeg', 'image/png', 'image/webp'],
  };

  beforeEach(() => {
    vi.clearAllMocks();
  });

  describe('Renderizado b치sico', () => {
    it('debe renderizar el componente correctamente', () => {
      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByTestId('dropzone')).toBeInTheDocument();
      expect(screen.getByTestId('file-input')).toBeInTheDocument();
      expect(screen.getByText('游늬')).toBeInTheDocument();
      expect(screen.getByText('Arrastra im치genes aqu칤 o haz clic para seleccionar')).toBeInTheDocument();
    });

    it('debe mostrar informaci칩n de l칤mites correctamente', () => {
      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByText('M치ximo 5 archivos, 5MB por archivo')).toBeInTheDocument();
      expect(screen.getByText('Formatos: JPEG, PNG, WEBP')).toBeInTheDocument();
    });

    it('debe aplicar clases CSS personalizadas', () => {
      render(<ImageUpload {...defaultProps} className="custom-class" />);
      
      const dropzone = screen.getByTestId('dropzone');
      expect(dropzone).toHaveClass('custom-class');
    });
  });

  describe('Estados de carga', () => {
    it('debe mostrar estado de carga cuando isLoading es true', async () => {
      // Mock useDropzone para simular loading
      const { useDropzone } = await import('react-dropzone');
      vi.mocked(useDropzone).mockReturnValue({
        getRootProps: () => ({ 'data-testid': 'dropzone' }),
        getInputProps: () => ({ 'data-testid': 'file-input' }),
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false,
        fileRejections: [],
      });

      render(<ImageUpload {...defaultProps} />);
      
      // El estado de loading se maneja internamente en handleDrop
      // Este test verifica que el componente renderiza sin errores
      expect(screen.getByTestId('dropzone')).toBeInTheDocument();
    });
  });

  describe('Componente deshabilitado', () => {
    it('debe aplicar estilos de disabled cuando disabled=true', () => {
      render(<ImageUpload {...defaultProps} disabled={true} />);
      
      const dropzone = screen.getByTestId('dropzone');
      expect(dropzone).toHaveClass('opacity-50', 'cursor-not-allowed');
    });
  });

  describe('Preview de im치genes', () => {
    it('no debe mostrar preview cuando showPreview=false', () => {
      render(<ImageUpload {...defaultProps} showPreview={false} />);
      
      // Como no hay im치genes cargadas, no deber칤a haber preview
      expect(screen.queryByText('Im치genes seleccionadas:')).not.toBeInTheDocument();
    });

    it('debe renderizar sin errores con props por defecto', () => {
      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByTestId('dropzone')).toBeInTheDocument();
    });
  });

  describe('Validaciones de archivos', () => {
    it('debe mostrar errores de validaci칩n cuando hay fileRejections', async () => {
      const { useDropzone } = await import('react-dropzone');
      vi.mocked(useDropzone).mockReturnValue({
        getRootProps: () => ({ 'data-testid': 'dropzone' }),
        getInputProps: () => ({ 'data-testid': 'file-input' }),
        isDragActive: false,
        isDragAccept: false,
        isDragReject: false,
        fileRejections: [
          {
            file: new File([''], 'test.txt', { type: 'text/plain' }) as File,
            errors: [{ code: 'file-invalid-type', message: 'Tipo de archivo no v치lido' }],
          },
        ],
      });

      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByText('Archivos rechazados:')).toBeInTheDocument();
      expect(screen.getByText('test.txt')).toBeInTheDocument();
      expect(screen.getByText(': Tipo de archivo no v치lido')).toBeInTheDocument();
    });
  });

  describe('Estados de drag & drop', () => {
    it('debe mostrar estado drag active', async () => {
      const { useDropzone } = await import('react-dropzone');
      vi.mocked(useDropzone).mockReturnValue({
        getRootProps: () => ({ 'data-testid': 'dropzone' }),
        getInputProps: () => ({ 'data-testid': 'file-input' }),
        isDragActive: true,
        isDragAccept: true,
        isDragReject: false,
        fileRejections: [],
      });

      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByText('Suelta las im치genes aqu칤...')).toBeInTheDocument();
    });

    it('debe mostrar estado drag reject', async () => {
      const { useDropzone } = await import('react-dropzone');
      vi.mocked(useDropzone).mockReturnValue({
        getRootProps: () => ({ 'data-testid': 'dropzone' }),
        getInputProps: () => ({ 'data-testid': 'file-input' }),
        isDragActive: true,
        isDragAccept: false,
        isDragReject: true,
        fileRejections: [],
      });

      render(<ImageUpload {...defaultProps} />);
      
      expect(screen.getByText('Tipo de archivo no soportado')).toBeInTheDocument();
    });
  });

  describe('Callback onImageUpload', () => {
    it('debe ser una funci칩n', () => {
      expect(typeof defaultProps.onImageUpload).toBe('function');
    });
  });

  describe('Limpieza de memoria', () => {
    it('debe limpiar URLs de preview al desmontar', () => {
      const { unmount } = render(<ImageUpload {...defaultProps} />);
      
      unmount();
      
      // El cleanup se hace en useEffect, verificamos que no hay errores
      expect(global.URL.revokeObjectURL).toHaveBeenCalledTimes(0); // No hay im치genes para limpiar
    });
  });
});